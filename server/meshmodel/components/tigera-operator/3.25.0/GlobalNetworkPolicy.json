{"kind":"GlobalNetworkPolicy","apiVersion":"v1","displayName":"Global Network Policy","format":"JSON","metadata":{"genealogy":"","logoURL":"https://layer5.io/company/brand","model":"tigera-operator","modelDisplayName":"tigera-operator","primaryColor":"#00B39F","published":false,"secondaryColor":"#00D3A9","shape":"circle","styleOverrides":"","subCategory":"Uncategorized","svgColor":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003c!DOCTYPE svg\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 32 32\" fill=\"none\"\u003e\n\u003cg xmlns=\"http://www.w3.org/2000/svg\" clip-path=\"url(#clip0_36_80)\"\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M16.4632 7.69351V15.2015L22.9702 11.4346L16.4632 7.69351Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M16.4632 16.7705V24.3157L23.0307 20.5607L16.4632 16.7705Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M15.5274 15.1502V7.75632L9.10194 11.4416L15.5274 15.1502Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M2.63699 24.2878C3.89756 26.3157 5.60178 28.031 7.62134 29.3047V21.4033L2.63699 24.2878Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M15.5274 24.2785V16.8264L9.08579 20.556L15.5274 24.2785Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M8.55965 28.8344L15.0829 25.1049L8.55965 21.3335V28.8344Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M23.4753 28.8742V21.3848L16.9615 25.1096L23.4753 28.8742Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M29.852 23.4194C30.9655 21.341 31.5949 19.0378 31.6935 16.6819L24.9119 20.5651L29.852 23.4194Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M24.4136 19.7691L30.96 16.0256L24.4136 12.2634V19.7691Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M23.4755 10.6455V3.20041L16.9919 6.91827L23.4755 10.6455Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M23.4754 19.7364V12.2239L16.9779 15.986L23.4754 19.7364Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M8.55965 12.2099V19.7784L15.1061 15.9882L8.55965 12.2099Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M15.5274 0.285706C13.1176 0.353534 10.756 0.977397 8.6271 2.10855L15.5274 6.06621V0.285706Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M8.55965 3.1492V10.6734L15.1107 6.91597L8.55965 3.1492Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M7.62134 2.69299C5.60228 3.96735 3.89818 5.6826 2.63699 7.7099L7.62134 10.5873V2.69299Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M23.4335 2.14811C21.2869 0.992986 18.9001 0.355226 16.4632 0.285706V6.14069L23.4335 2.14811Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M0.285713 16.5517C0.367085 18.9754 1.01023 21.3471 2.16447 23.4799L7.21396 20.5559L0.285713 16.5517Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M2.16447 8.51996C1.01384 10.6433 0.370833 13.0043 0.285713 15.4178L7.22097 11.4393L2.16447 8.51996Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M8.61544 29.8822C10.7469 31.0189 13.1128 31.6461 15.5274 31.7143V25.9291L8.61544 29.8822Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M29.3675 7.73539C28.1143 5.71396 26.4208 4.00147 24.4136 2.72543V10.5987L29.3675 7.73539Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M24.4136 29.2791C26.4312 27.994 28.1314 26.2684 29.3863 24.2321L24.4136 21.3591V29.2791Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M31.7143 15.3738C31.6251 12.9835 30.9879 10.6458 29.8518 8.54102L24.8441 11.4325L31.7143 15.3738Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M16.4632 31.7143C18.8725 31.6467 21.2333 31.0229 23.3613 29.8914L16.4632 25.8942V31.7143Z\" fill=\"white\"\u003e\u003c/path\u003e\n\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M7.62141 19.711V12.2892L1.17738 15.9838L7.62141 19.711Z\" fill=\"white\" fill-opacity=\"0.8\"\u003e\u003c/path\u003e\n\u003c/g\u003e\n\u003cdefs xmlns=\"http://www.w3.org/2000/svg\"\u003e\n\u003cclipPath xmlns=\"http://www.w3.org/2000/svg\" id=\"clip0_36_80\"\u003e\n\u003crect xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" fill=\"white\"\u003e\u003c/rect\u003e\n\u003c/clipPath\u003e\n\u003c/defs\u003e\n\u003c/svg\u003e","svgComplete":"","svgWhite":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003c!DOCTYPE svg\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 32 32\" fill=\"none\"\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M16.405 8.732v6.57l5.694-3.297-5.694-3.273Zm0 7.942v6.602l5.747-3.285-5.747-3.317Z\" fill=\"#fff\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M15.586 15.256v-6.47l-5.622 3.225 5.622 3.245ZM4.307 23.252a13.809 13.809 0 0 0 4.362 4.39v-6.914l-4.362 2.524Zm11.279-.008v-6.52L9.95 19.985l5.636 3.258Z\" fill=\"#fff\" fill-opacity=\".8\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"m9.49 27.23 5.707-3.263-5.707-3.3v6.563Z\" fill=\"#fff\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M22.54 27.265v-6.553l-5.699 3.259 5.7 3.294Zm5.58-4.773a13.697 13.697 0 0 0 1.612-5.895l-5.934 3.397 4.323 2.498Z\" fill=\"#fff\" fill-opacity=\".8\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"m23.362 19.298 5.728-3.276-5.728-3.291v6.567Z\" fill=\"#fff\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M22.541 11.315V4.8l-5.673 3.253 5.673 3.262Zm0 7.955v-6.574l-5.685 3.292 5.685 3.281Z\" fill=\"#fff\" fill-opacity=\".8\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M9.49 12.684v6.622l5.728-3.316-5.728-3.306Z\" fill=\"#fff\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M15.586 2.25a13.69 13.69 0 0 0-6.037 1.595l6.037 3.463V2.25Z\" fill=\"#fff\" fill-opacity=\".8\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M9.49 4.756v6.583l5.732-3.288L9.49 4.756Z\" fill=\"#fff\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M8.669 4.356a13.83 13.83 0 0 0-4.362 4.39l4.362 2.518V4.356Z\" fill=\"#fff\" fill-opacity=\".8\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M22.504 3.88a13.695 13.695 0 0 0-6.099-1.63v5.123l6.1-3.493ZM2.25 16.483c.071 2.12.634 4.196 1.644 6.062l4.418-2.559-6.062-3.503Zm1.644-7.028a13.68 13.68 0 0 0-1.644 6.036l6.068-3.482-4.424-2.554Z\" fill=\"#fff\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M9.539 28.147a13.673 13.673 0 0 0 6.047 1.603v-5.062L9.54 28.147Z\" fill=\"#fff\" fill-opacity=\".8\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M27.697 8.768a13.83 13.83 0 0 0-4.335-4.383v6.889l4.335-2.506ZM23.362 27.62a13.851 13.851 0 0 0 4.351-4.417l-4.351-2.514v6.93Z\" fill=\"#fff\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M29.75 15.452a13.659 13.659 0 0 0-1.63-5.979l-4.381 2.53 6.011 3.45Z\" fill=\"#fff\" fill-opacity=\".8\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M16.405 29.75a13.673 13.673 0 0 0 6.036-1.595l-6.036-3.498v5.093Z\" fill=\"#fff\"\u003e\u003c/path\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" d=\"M8.669 19.247v-6.494L3.03 15.986l5.639 3.261Z\" fill=\"#fff\" fill-opacity=\".8\"\u003e\u003c/path\u003e\u003c/svg\u003e"},"model":{"name":"tigera-operator","version":"3.25.0","displayName":"tigera-operator","category":{"name":"Uncategorized","metadata":null},"metadata":null},"schema":"{\n \"properties\": {\n  \"applyOnForward\": {\n   \"description\": \"ApplyOnForward indicates to apply the rules in this policy on forward traffic.\",\n   \"type\": \"boolean\"\n  },\n  \"doNotTrack\": {\n   \"description\": \"DoNotTrack indicates whether packets matched by the rules in this policy should go through the data plane's connection tracking, such as Linux conntrack.  If True, the rules in this policy are applied before any data plane connection tracking, and packets allowed by this policy are marked as not to be tracked.\",\n   \"type\": \"boolean\"\n  },\n  \"egress\": {\n   \"description\": \"The ordered set of egress rules.  Each rule contains a set of packet match criteria and a corresponding action to apply.\",\n   \"items\": {\n    \"description\": \"A Rule encapsulates a set of match criteria and an action.  Both selector-based security Policy and security Profiles reference rules - separated out as a list of rules for both ingress and egress packet matching. \\n Each positive match criteria has a negated version, prefixed with \\\"Not\\\". All the match criteria within a rule must be satisfied for a packet to match. A single rule can contain the positive and negative version of a match and both must be satisfied for the rule to match.\",\n    \"properties\": {\n     \"action\": {\n      \"type\": \"string\"\n     },\n     \"destination\": {\n      \"description\": \"Destination contains the match criteria that apply to destination entity.\",\n      \"properties\": {\n       \"namespaceSelector\": {\n        \"description\": \"NamespaceSelector is an optional field that contains a selector expression. Only traffic that originates from (or terminates at) endpoints within the selected namespaces will be matched. When both NamespaceSelector and another selector are defined on the same rule, then only workload endpoints that are matched by both selectors will be selected by the rule. \\n For NetworkPolicy, an empty NamespaceSelector implies that the Selector is limited to selecting only workload endpoints in the same namespace as the NetworkPolicy. \\n For NetworkPolicy, `global()` NamespaceSelector implies that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint. \\n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies to workload endpoints across all namespaces.\",\n        \"type\": \"string\"\n       },\n       \"nets\": {\n        \"description\": \"Nets is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) IP addresses in any of the given subnets.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"notNets\": {\n        \"description\": \"NotNets is the negated version of the Nets field.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"notPorts\": {\n        \"description\": \"NotPorts is the negated version of the Ports field. Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \\\"TCP\\\" or \\\"UDP\\\".\",\n        \"items\": {\n         \"anyOf\": [\n          {\n           \"type\": \"integer\"\n          },\n          {\n           \"type\": \"string\"\n          }\n         ],\n         \"pattern\": \"^.*\",\n         \"x-kubernetes-int-or-string\": true\n        },\n        \"type\": \"array\"\n       },\n       \"notSelector\": {\n        \"description\": \"NotSelector is the negated version of the Selector field.  See Selector field for subtleties with negated selectors.\",\n        \"type\": \"string\"\n       },\n       \"ports\": {\n        \"description\": \"Ports is an optional field that restricts the rule to only apply to traffic that has a source (destination) port that matches one of these ranges/values. This value is a list of integers or strings that represent ranges of ports. \\n Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \\\"TCP\\\" or \\\"UDP\\\".\",\n        \"items\": {\n         \"anyOf\": [\n          {\n           \"type\": \"integer\"\n          },\n          {\n           \"type\": \"string\"\n          }\n         ],\n         \"pattern\": \"^.*\",\n         \"x-kubernetes-int-or-string\": true\n        },\n        \"type\": \"array\"\n       },\n       \"selector\": {\n        \"description\": \"Selector is an optional field that contains a selector expression (see Policy for sample syntax).  Only traffic that originates from (terminates at) endpoints matching the selector will be matched. \\n Note that: in addition to the negated version of the Selector (see NotSelector below), the selector expression syntax itself supports negation.  The two types of negation are subtly different. One negates the set of matched endpoints, the other negates the whole match: \\n \\tSelector = \\\"!has(my_label)\\\" matches packets that are from other Calico-controlled \\tendpoints that do not have the label \\\"my_label\\\". \\n \\tNotSelector = \\\"has(my_label)\\\" matches packets that are not from Calico-controlled \\tendpoints that do have the label \\\"my_label\\\". \\n The effect is that the latter will accept packets from non-Calico sources whereas the former is limited to packets from Calico-controlled endpoints.\",\n        \"type\": \"string\"\n       },\n       \"serviceAccounts\": {\n        \"description\": \"ServiceAccounts is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a matching service account.\",\n        \"properties\": {\n         \"names\": {\n          \"description\": \"Names is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a service account whose name is in the list.\",\n          \"items\": {\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         },\n         \"selector\": {\n          \"description\": \"Selector is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a service account that matches the given label selector. If both Names and Selector are specified then they are AND'ed.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"services\": {\n        \"description\": \"Services is an optional field that contains options for matching Kubernetes Services. If specified, only traffic that originates from or terminates at endpoints within the selected service(s) will be matched, and only to/from each endpoint's port. \\n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector, Nets, NotNets or ServiceAccounts. \\n Ports and NotPorts can only be specified with Services on ingress rules.\",\n        \"properties\": {\n         \"name\": {\n          \"description\": \"Name specifies the name of a Kubernetes Service to match.\",\n          \"type\": \"string\"\n         },\n         \"namespace\": {\n          \"description\": \"Namespace specifies the namespace of the given Service. If left empty, the rule will match within this policy's namespace.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"http\": {\n      \"description\": \"HTTP contains match criteria that apply to HTTP requests.\",\n      \"properties\": {\n       \"methods\": {\n        \"description\": \"Methods is an optional field that restricts the rule to apply only to HTTP requests that use one of the listed HTTP Methods (e.g. GET, PUT, etc.) Multiple methods are OR'd together.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"paths\": {\n        \"description\": \"Paths is an optional field that restricts the rule to apply to HTTP requests that use one of the listed HTTP Paths. Multiple paths are OR'd together. e.g: - exact: /foo - prefix: /bar NOTE: Each entry may ONLY specify either a `exact` or a `prefix` match. The validator will check for it.\",\n        \"items\": {\n         \"description\": \"HTTPPath specifies an HTTP path to match. It may be either of the form: exact: \\u003cpath\\u003e: which matches the path exactly or prefix: \\u003cpath-prefix\\u003e: which matches the path prefix\",\n         \"properties\": {\n          \"exact\": {\n           \"type\": \"string\"\n          },\n          \"prefix\": {\n           \"type\": \"string\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"type\": \"array\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"icmp\": {\n      \"description\": \"ICMP is an optional field that restricts the rule to apply to a specific type and code of ICMP traffic.  This should only be specified if the Protocol field is set to \\\"ICMP\\\" or \\\"ICMPv6\\\".\",\n      \"properties\": {\n       \"code\": {\n        \"description\": \"Match on a specific ICMP code.  If specified, the Type value must also be specified. This is a technical limitation imposed by the kernel's iptables firewall, which Calico uses to enforce the rule.\",\n        \"type\": \"integer\"\n       },\n       \"type\": {\n        \"description\": \"Match on a specific ICMP type.  For example a value of 8 refers to ICMP Echo Request (i.e. pings).\",\n        \"type\": \"integer\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"ipVersion\": {\n      \"description\": \"IPVersion is an optional field that restricts the rule to only match a specific IP version.\",\n      \"type\": \"integer\"\n     },\n     \"metadata\": {\n      \"description\": \"Metadata contains additional information for this rule\",\n      \"properties\": {\n       \"annotations\": {\n        \"additionalProperties\": {\n         \"type\": \"string\"\n        },\n        \"description\": \"Annotations is a set of key value pairs that give extra information about the rule\",\n        \"type\": \"object\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"notICMP\": {\n      \"description\": \"NotICMP is the negated version of the ICMP field.\",\n      \"properties\": {\n       \"code\": {\n        \"description\": \"Match on a specific ICMP code.  If specified, the Type value must also be specified. This is a technical limitation imposed by the kernel's iptables firewall, which Calico uses to enforce the rule.\",\n        \"type\": \"integer\"\n       },\n       \"type\": {\n        \"description\": \"Match on a specific ICMP type.  For example a value of 8 refers to ICMP Echo Request (i.e. pings).\",\n        \"type\": \"integer\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"notProtocol\": {\n      \"anyOf\": [\n       {\n        \"type\": \"integer\"\n       },\n       {\n        \"type\": \"string\"\n       }\n      ],\n      \"description\": \"NotProtocol is the negated version of the Protocol field.\",\n      \"pattern\": \"^.*\",\n      \"x-kubernetes-int-or-string\": true\n     },\n     \"protocol\": {\n      \"anyOf\": [\n       {\n        \"type\": \"integer\"\n       },\n       {\n        \"type\": \"string\"\n       }\n      ],\n      \"description\": \"Protocol is an optional field that restricts the rule to only apply to traffic of a specific IP protocol. Required if any of the EntityRules contain Ports (because ports only apply to certain protocols). \\n Must be one of these string values: \\\"TCP\\\", \\\"UDP\\\", \\\"ICMP\\\", \\\"ICMPv6\\\", \\\"SCTP\\\", \\\"UDPLite\\\" or an integer in the range 1-255.\",\n      \"pattern\": \"^.*\",\n      \"x-kubernetes-int-or-string\": true\n     },\n     \"source\": {\n      \"description\": \"Source contains the match criteria that apply to source entity.\",\n      \"properties\": {\n       \"namespaceSelector\": {\n        \"description\": \"NamespaceSelector is an optional field that contains a selector expression. Only traffic that originates from (or terminates at) endpoints within the selected namespaces will be matched. When both NamespaceSelector and another selector are defined on the same rule, then only workload endpoints that are matched by both selectors will be selected by the rule. \\n For NetworkPolicy, an empty NamespaceSelector implies that the Selector is limited to selecting only workload endpoints in the same namespace as the NetworkPolicy. \\n For NetworkPolicy, `global()` NamespaceSelector implies that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint. \\n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies to workload endpoints across all namespaces.\",\n        \"type\": \"string\"\n       },\n       \"nets\": {\n        \"description\": \"Nets is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) IP addresses in any of the given subnets.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"notNets\": {\n        \"description\": \"NotNets is the negated version of the Nets field.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"notPorts\": {\n        \"description\": \"NotPorts is the negated version of the Ports field. Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \\\"TCP\\\" or \\\"UDP\\\".\",\n        \"items\": {\n         \"anyOf\": [\n          {\n           \"type\": \"integer\"\n          },\n          {\n           \"type\": \"string\"\n          }\n         ],\n         \"pattern\": \"^.*\",\n         \"x-kubernetes-int-or-string\": true\n        },\n        \"type\": \"array\"\n       },\n       \"notSelector\": {\n        \"description\": \"NotSelector is the negated version of the Selector field.  See Selector field for subtleties with negated selectors.\",\n        \"type\": \"string\"\n       },\n       \"ports\": {\n        \"description\": \"Ports is an optional field that restricts the rule to only apply to traffic that has a source (destination) port that matches one of these ranges/values. This value is a list of integers or strings that represent ranges of ports. \\n Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \\\"TCP\\\" or \\\"UDP\\\".\",\n        \"items\": {\n         \"anyOf\": [\n          {\n           \"type\": \"integer\"\n          },\n          {\n           \"type\": \"string\"\n          }\n         ],\n         \"pattern\": \"^.*\",\n         \"x-kubernetes-int-or-string\": true\n        },\n        \"type\": \"array\"\n       },\n       \"selector\": {\n        \"description\": \"Selector is an optional field that contains a selector expression (see Policy for sample syntax).  Only traffic that originates from (terminates at) endpoints matching the selector will be matched. \\n Note that: in addition to the negated version of the Selector (see NotSelector below), the selector expression syntax itself supports negation.  The two types of negation are subtly different. One negates the set of matched endpoints, the other negates the whole match: \\n \\tSelector = \\\"!has(my_label)\\\" matches packets that are from other Calico-controlled \\tendpoints that do not have the label \\\"my_label\\\". \\n \\tNotSelector = \\\"has(my_label)\\\" matches packets that are not from Calico-controlled \\tendpoints that do have the label \\\"my_label\\\". \\n The effect is that the latter will accept packets from non-Calico sources whereas the former is limited to packets from Calico-controlled endpoints.\",\n        \"type\": \"string\"\n       },\n       \"serviceAccounts\": {\n        \"description\": \"ServiceAccounts is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a matching service account.\",\n        \"properties\": {\n         \"names\": {\n          \"description\": \"Names is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a service account whose name is in the list.\",\n          \"items\": {\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         },\n         \"selector\": {\n          \"description\": \"Selector is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a service account that matches the given label selector. If both Names and Selector are specified then they are AND'ed.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"services\": {\n        \"description\": \"Services is an optional field that contains options for matching Kubernetes Services. If specified, only traffic that originates from or terminates at endpoints within the selected service(s) will be matched, and only to/from each endpoint's port. \\n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector, Nets, NotNets or ServiceAccounts. \\n Ports and NotPorts can only be specified with Services on ingress rules.\",\n        \"properties\": {\n         \"name\": {\n          \"description\": \"Name specifies the name of a Kubernetes Service to match.\",\n          \"type\": \"string\"\n         },\n         \"namespace\": {\n          \"description\": \"Namespace specifies the namespace of the given Service. If left empty, the rule will match within this policy's namespace.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       }\n      },\n      \"type\": \"object\"\n     }\n    },\n    \"required\": [\n     \"action\"\n    ],\n    \"type\": \"object\"\n   },\n   \"type\": \"array\"\n  },\n  \"ingress\": {\n   \"description\": \"The ordered set of ingress rules.  Each rule contains a set of packet match criteria and a corresponding action to apply.\",\n   \"items\": {\n    \"description\": \"A Rule encapsulates a set of match criteria and an action.  Both selector-based security Policy and security Profiles reference rules - separated out as a list of rules for both ingress and egress packet matching. \\n Each positive match criteria has a negated version, prefixed with \\\"Not\\\". All the match criteria within a rule must be satisfied for a packet to match. A single rule can contain the positive and negative version of a match and both must be satisfied for the rule to match.\",\n    \"properties\": {\n     \"action\": {\n      \"type\": \"string\"\n     },\n     \"destination\": {\n      \"description\": \"Destination contains the match criteria that apply to destination entity.\",\n      \"properties\": {\n       \"namespaceSelector\": {\n        \"description\": \"NamespaceSelector is an optional field that contains a selector expression. Only traffic that originates from (or terminates at) endpoints within the selected namespaces will be matched. When both NamespaceSelector and another selector are defined on the same rule, then only workload endpoints that are matched by both selectors will be selected by the rule. \\n For NetworkPolicy, an empty NamespaceSelector implies that the Selector is limited to selecting only workload endpoints in the same namespace as the NetworkPolicy. \\n For NetworkPolicy, `global()` NamespaceSelector implies that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint. \\n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies to workload endpoints across all namespaces.\",\n        \"type\": \"string\"\n       },\n       \"nets\": {\n        \"description\": \"Nets is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) IP addresses in any of the given subnets.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"notNets\": {\n        \"description\": \"NotNets is the negated version of the Nets field.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"notPorts\": {\n        \"description\": \"NotPorts is the negated version of the Ports field. Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \\\"TCP\\\" or \\\"UDP\\\".\",\n        \"items\": {\n         \"anyOf\": [\n          {\n           \"type\": \"integer\"\n          },\n          {\n           \"type\": \"string\"\n          }\n         ],\n         \"pattern\": \"^.*\",\n         \"x-kubernetes-int-or-string\": true\n        },\n        \"type\": \"array\"\n       },\n       \"notSelector\": {\n        \"description\": \"NotSelector is the negated version of the Selector field.  See Selector field for subtleties with negated selectors.\",\n        \"type\": \"string\"\n       },\n       \"ports\": {\n        \"description\": \"Ports is an optional field that restricts the rule to only apply to traffic that has a source (destination) port that matches one of these ranges/values. This value is a list of integers or strings that represent ranges of ports. \\n Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \\\"TCP\\\" or \\\"UDP\\\".\",\n        \"items\": {\n         \"anyOf\": [\n          {\n           \"type\": \"integer\"\n          },\n          {\n           \"type\": \"string\"\n          }\n         ],\n         \"pattern\": \"^.*\",\n         \"x-kubernetes-int-or-string\": true\n        },\n        \"type\": \"array\"\n       },\n       \"selector\": {\n        \"description\": \"Selector is an optional field that contains a selector expression (see Policy for sample syntax).  Only traffic that originates from (terminates at) endpoints matching the selector will be matched. \\n Note that: in addition to the negated version of the Selector (see NotSelector below), the selector expression syntax itself supports negation.  The two types of negation are subtly different. One negates the set of matched endpoints, the other negates the whole match: \\n \\tSelector = \\\"!has(my_label)\\\" matches packets that are from other Calico-controlled \\tendpoints that do not have the label \\\"my_label\\\". \\n \\tNotSelector = \\\"has(my_label)\\\" matches packets that are not from Calico-controlled \\tendpoints that do have the label \\\"my_label\\\". \\n The effect is that the latter will accept packets from non-Calico sources whereas the former is limited to packets from Calico-controlled endpoints.\",\n        \"type\": \"string\"\n       },\n       \"serviceAccounts\": {\n        \"description\": \"ServiceAccounts is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a matching service account.\",\n        \"properties\": {\n         \"names\": {\n          \"description\": \"Names is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a service account whose name is in the list.\",\n          \"items\": {\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         },\n         \"selector\": {\n          \"description\": \"Selector is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a service account that matches the given label selector. If both Names and Selector are specified then they are AND'ed.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"services\": {\n        \"description\": \"Services is an optional field that contains options for matching Kubernetes Services. If specified, only traffic that originates from or terminates at endpoints within the selected service(s) will be matched, and only to/from each endpoint's port. \\n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector, Nets, NotNets or ServiceAccounts. \\n Ports and NotPorts can only be specified with Services on ingress rules.\",\n        \"properties\": {\n         \"name\": {\n          \"description\": \"Name specifies the name of a Kubernetes Service to match.\",\n          \"type\": \"string\"\n         },\n         \"namespace\": {\n          \"description\": \"Namespace specifies the namespace of the given Service. If left empty, the rule will match within this policy's namespace.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"http\": {\n      \"description\": \"HTTP contains match criteria that apply to HTTP requests.\",\n      \"properties\": {\n       \"methods\": {\n        \"description\": \"Methods is an optional field that restricts the rule to apply only to HTTP requests that use one of the listed HTTP Methods (e.g. GET, PUT, etc.) Multiple methods are OR'd together.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"paths\": {\n        \"description\": \"Paths is an optional field that restricts the rule to apply to HTTP requests that use one of the listed HTTP Paths. Multiple paths are OR'd together. e.g: - exact: /foo - prefix: /bar NOTE: Each entry may ONLY specify either a `exact` or a `prefix` match. The validator will check for it.\",\n        \"items\": {\n         \"description\": \"HTTPPath specifies an HTTP path to match. It may be either of the form: exact: \\u003cpath\\u003e: which matches the path exactly or prefix: \\u003cpath-prefix\\u003e: which matches the path prefix\",\n         \"properties\": {\n          \"exact\": {\n           \"type\": \"string\"\n          },\n          \"prefix\": {\n           \"type\": \"string\"\n          }\n         },\n         \"type\": \"object\"\n        },\n        \"type\": \"array\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"icmp\": {\n      \"description\": \"ICMP is an optional field that restricts the rule to apply to a specific type and code of ICMP traffic.  This should only be specified if the Protocol field is set to \\\"ICMP\\\" or \\\"ICMPv6\\\".\",\n      \"properties\": {\n       \"code\": {\n        \"description\": \"Match on a specific ICMP code.  If specified, the Type value must also be specified. This is a technical limitation imposed by the kernel's iptables firewall, which Calico uses to enforce the rule.\",\n        \"type\": \"integer\"\n       },\n       \"type\": {\n        \"description\": \"Match on a specific ICMP type.  For example a value of 8 refers to ICMP Echo Request (i.e. pings).\",\n        \"type\": \"integer\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"ipVersion\": {\n      \"description\": \"IPVersion is an optional field that restricts the rule to only match a specific IP version.\",\n      \"type\": \"integer\"\n     },\n     \"metadata\": {\n      \"description\": \"Metadata contains additional information for this rule\",\n      \"properties\": {\n       \"annotations\": {\n        \"additionalProperties\": {\n         \"type\": \"string\"\n        },\n        \"description\": \"Annotations is a set of key value pairs that give extra information about the rule\",\n        \"type\": \"object\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"notICMP\": {\n      \"description\": \"NotICMP is the negated version of the ICMP field.\",\n      \"properties\": {\n       \"code\": {\n        \"description\": \"Match on a specific ICMP code.  If specified, the Type value must also be specified. This is a technical limitation imposed by the kernel's iptables firewall, which Calico uses to enforce the rule.\",\n        \"type\": \"integer\"\n       },\n       \"type\": {\n        \"description\": \"Match on a specific ICMP type.  For example a value of 8 refers to ICMP Echo Request (i.e. pings).\",\n        \"type\": \"integer\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"notProtocol\": {\n      \"anyOf\": [\n       {\n        \"type\": \"integer\"\n       },\n       {\n        \"type\": \"string\"\n       }\n      ],\n      \"description\": \"NotProtocol is the negated version of the Protocol field.\",\n      \"pattern\": \"^.*\",\n      \"x-kubernetes-int-or-string\": true\n     },\n     \"protocol\": {\n      \"anyOf\": [\n       {\n        \"type\": \"integer\"\n       },\n       {\n        \"type\": \"string\"\n       }\n      ],\n      \"description\": \"Protocol is an optional field that restricts the rule to only apply to traffic of a specific IP protocol. Required if any of the EntityRules contain Ports (because ports only apply to certain protocols). \\n Must be one of these string values: \\\"TCP\\\", \\\"UDP\\\", \\\"ICMP\\\", \\\"ICMPv6\\\", \\\"SCTP\\\", \\\"UDPLite\\\" or an integer in the range 1-255.\",\n      \"pattern\": \"^.*\",\n      \"x-kubernetes-int-or-string\": true\n     },\n     \"source\": {\n      \"description\": \"Source contains the match criteria that apply to source entity.\",\n      \"properties\": {\n       \"namespaceSelector\": {\n        \"description\": \"NamespaceSelector is an optional field that contains a selector expression. Only traffic that originates from (or terminates at) endpoints within the selected namespaces will be matched. When both NamespaceSelector and another selector are defined on the same rule, then only workload endpoints that are matched by both selectors will be selected by the rule. \\n For NetworkPolicy, an empty NamespaceSelector implies that the Selector is limited to selecting only workload endpoints in the same namespace as the NetworkPolicy. \\n For NetworkPolicy, `global()` NamespaceSelector implies that the Selector is limited to selecting only GlobalNetworkSet or HostEndpoint. \\n For GlobalNetworkPolicy, an empty NamespaceSelector implies the Selector applies to workload endpoints across all namespaces.\",\n        \"type\": \"string\"\n       },\n       \"nets\": {\n        \"description\": \"Nets is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) IP addresses in any of the given subnets.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"notNets\": {\n        \"description\": \"NotNets is the negated version of the Nets field.\",\n        \"items\": {\n         \"type\": \"string\"\n        },\n        \"type\": \"array\"\n       },\n       \"notPorts\": {\n        \"description\": \"NotPorts is the negated version of the Ports field. Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \\\"TCP\\\" or \\\"UDP\\\".\",\n        \"items\": {\n         \"anyOf\": [\n          {\n           \"type\": \"integer\"\n          },\n          {\n           \"type\": \"string\"\n          }\n         ],\n         \"pattern\": \"^.*\",\n         \"x-kubernetes-int-or-string\": true\n        },\n        \"type\": \"array\"\n       },\n       \"notSelector\": {\n        \"description\": \"NotSelector is the negated version of the Selector field.  See Selector field for subtleties with negated selectors.\",\n        \"type\": \"string\"\n       },\n       \"ports\": {\n        \"description\": \"Ports is an optional field that restricts the rule to only apply to traffic that has a source (destination) port that matches one of these ranges/values. This value is a list of integers or strings that represent ranges of ports. \\n Since only some protocols have ports, if any ports are specified it requires the Protocol match in the Rule to be set to \\\"TCP\\\" or \\\"UDP\\\".\",\n        \"items\": {\n         \"anyOf\": [\n          {\n           \"type\": \"integer\"\n          },\n          {\n           \"type\": \"string\"\n          }\n         ],\n         \"pattern\": \"^.*\",\n         \"x-kubernetes-int-or-string\": true\n        },\n        \"type\": \"array\"\n       },\n       \"selector\": {\n        \"description\": \"Selector is an optional field that contains a selector expression (see Policy for sample syntax).  Only traffic that originates from (terminates at) endpoints matching the selector will be matched. \\n Note that: in addition to the negated version of the Selector (see NotSelector below), the selector expression syntax itself supports negation.  The two types of negation are subtly different. One negates the set of matched endpoints, the other negates the whole match: \\n \\tSelector = \\\"!has(my_label)\\\" matches packets that are from other Calico-controlled \\tendpoints that do not have the label \\\"my_label\\\". \\n \\tNotSelector = \\\"has(my_label)\\\" matches packets that are not from Calico-controlled \\tendpoints that do have the label \\\"my_label\\\". \\n The effect is that the latter will accept packets from non-Calico sources whereas the former is limited to packets from Calico-controlled endpoints.\",\n        \"type\": \"string\"\n       },\n       \"serviceAccounts\": {\n        \"description\": \"ServiceAccounts is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a matching service account.\",\n        \"properties\": {\n         \"names\": {\n          \"description\": \"Names is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a service account whose name is in the list.\",\n          \"items\": {\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         },\n         \"selector\": {\n          \"description\": \"Selector is an optional field that restricts the rule to only apply to traffic that originates from (or terminates at) a pod running as a service account that matches the given label selector. If both Names and Selector are specified then they are AND'ed.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"services\": {\n        \"description\": \"Services is an optional field that contains options for matching Kubernetes Services. If specified, only traffic that originates from or terminates at endpoints within the selected service(s) will be matched, and only to/from each endpoint's port. \\n Services cannot be specified on the same rule as Selector, NotSelector, NamespaceSelector, Nets, NotNets or ServiceAccounts. \\n Ports and NotPorts can only be specified with Services on ingress rules.\",\n        \"properties\": {\n         \"name\": {\n          \"description\": \"Name specifies the name of a Kubernetes Service to match.\",\n          \"type\": \"string\"\n         },\n         \"namespace\": {\n          \"description\": \"Namespace specifies the namespace of the given Service. If left empty, the rule will match within this policy's namespace.\",\n          \"type\": \"string\"\n         }\n        },\n        \"type\": \"object\"\n       }\n      },\n      \"type\": \"object\"\n     }\n    },\n    \"required\": [\n     \"action\"\n    ],\n    \"type\": \"object\"\n   },\n   \"type\": \"array\"\n  },\n  \"namespaceSelector\": {\n   \"description\": \"NamespaceSelector is an optional field for an expression used to select a pod based on namespaces.\",\n   \"type\": \"string\"\n  },\n  \"order\": {\n   \"description\": \"Order is an optional field that specifies the order in which the policy is applied. Policies with higher \\\"order\\\" are applied after those with lower order.  If the order is omitted, it may be considered to be \\\"infinite\\\" - i.e. the policy will be applied last.  Policies with identical order will be applied in alphanumerical order based on the Policy \\\"Name\\\".\",\n   \"type\": \"number\"\n  },\n  \"preDNAT\": {\n   \"description\": \"PreDNAT indicates to apply the rules in this policy before any DNAT.\",\n   \"type\": \"boolean\"\n  },\n  \"selector\": {\n   \"description\": \"The selector is an expression used to pick pick out the endpoints that the policy should be applied to. \\n Selector expressions follow this syntax: \\n \\tlabel == \\\"string_literal\\\"  -\\u003e  comparison, e.g. my_label == \\\"foo bar\\\" \\tlabel != \\\"string_literal\\\"   -\\u003e  not equal; also matches if label is not present \\tlabel in { \\\"a\\\", \\\"b\\\", \\\"c\\\", ... }  -\\u003e  true if the value of label X is one of \\\"a\\\", \\\"b\\\", \\\"c\\\" \\tlabel not in { \\\"a\\\", \\\"b\\\", \\\"c\\\", ... }  -\\u003e  true if the value of label X is not one of \\\"a\\\", \\\"b\\\", \\\"c\\\" \\thas(label_name)  -\\u003e True if that label is present \\t! expr -\\u003e negation of expr \\texpr \\u0026\\u0026 expr  -\\u003e Short-circuit and \\texpr || expr  -\\u003e Short-circuit or \\t( expr ) -\\u003e parens for grouping \\tall() or the empty selector -\\u003e matches all endpoints. \\n Label names are allowed to contain alphanumerics, -, _ and /. String literals are more permissive but they do not support escape characters. \\n Examples (with made-up labels): \\n \\ttype == \\\"webserver\\\" \\u0026\\u0026 deployment == \\\"prod\\\" \\ttype in {\\\"frontend\\\", \\\"backend\\\"} \\tdeployment != \\\"dev\\\" \\t! has(label_name)\",\n   \"type\": \"string\"\n  },\n  \"serviceAccountSelector\": {\n   \"description\": \"ServiceAccountSelector is an optional field for an expression used to select a pod based on service accounts.\",\n   \"type\": \"string\"\n  },\n  \"types\": {\n   \"description\": \"Types indicates whether this policy applies to ingress, or to egress, or to both.  When not explicitly specified (and so the value on creation is empty or nil), Calico defaults Types according to what Ingress and Egress rules are present in the policy.  The default is: \\n - [ PolicyTypeIngress ], if there are no Egress rules (including the case where there are   also no Ingress rules) \\n - [ PolicyTypeEgress ], if there are Egress rules but no Ingress rules \\n - [ PolicyTypeIngress, PolicyTypeEgress ], if there are both Ingress and Egress rules. \\n When the policy is read back again, Types will always be one of these values, never empty or nil.\",\n   \"items\": {\n    \"description\": \"PolicyType enumerates the possible values of the PolicySpec Types field.\",\n    \"type\": \"string\"\n   },\n   \"type\": \"array\"\n  }\n },\n \"title\": \"Global Network Policy\",\n \"type\": \"object\"\n}"}