{"kind":"Cluster","apiVersion":"v1","displayName":"Cluster","format":"JSON","metadata":{"genealogy":"","logoURL":"https://github.com/cncf/artwork/blob/master/projects/prometheus/icon/color/prometheus-icon-color.svg","model":"prometheus","modelDisplayName":"Prometheus","primaryColor":"#e75225","published":true,"secondaryColor":"#e9633b","shape":"circle","styleOverrides":"","subCategory":"Monitoring","svgColor":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003c!DOCTYPE svg\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" role=\"img\" viewBox=\"-3.94 -1.44 438.62 432.87\" height=\"20\" width=\"20\"\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" fill=\"#E75225\" d=\"M215.926 7.068c115.684.024 210.638 93.784 210.493 207.844-.148 115.793-94.713 208.252-212.912 208.169C97.95 423 4.52 329.143 4.601 213.221 4.68 99.867 99.833 7.044 215.926 7.068zm-63.947 73.001c2.652 12.978.076 25.082-3.846 36.988-2.716 8.244-6.47 16.183-8.711 24.539-3.694 13.769-7.885 27.619-9.422 41.701-2.21 20.25 5.795 38.086 19.493 55.822L86.527 225.94c.11 1.978-.007 2.727.21 3.361 5.968 17.43 16.471 32.115 28.243 45.957 1.246 1.465 4.082 2.217 6.182 2.221 62.782.115 125.565.109 188.347.028 1.948-.003 4.546-.369 5.741-1.618 13.456-14.063 23.746-30.079 30.179-50.257l-66.658 12.976c4.397-8.567 9.417-16.1 12.302-24.377 9.869-28.315 5.779-55.69-8.387-81.509-11.368-20.72-21.854-41.349-16.183-66.32-12.005 11.786-16.615 26.79-19.541 42.253-2.882 15.23-4.58 30.684-6.811 46.136-.317-.467-.728-.811-.792-1.212-.258-1.621-.499-3.255-.587-4.893-1.355-25.31-6.328-49.696-16.823-72.987-6.178-13.71-12.99-27.727-6.622-44.081-4.31 2.259-8.205 4.505-10.997 7.711-8.333 9.569-11.779 21.062-12.666 33.645-.757 10.75-1.796 21.552-3.801 32.123-2.107 11.109-5.448 21.998-12.956 32.209-3.033-21.81-3.37-43.38-22.928-57.237zm161.877 216.523H116.942v34.007h196.914v-34.007zm-157.871 51.575c-.163 28.317 28.851 49.414 64.709 47.883 29.716-1.269 56.016-24.51 53.755-47.883H155.985z\"\u003e\u003c/path\u003e\u003c/svg\u003e","svgComplete":"","svgWhite":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003c!DOCTYPE svg\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" role=\"img\" viewBox=\"-1.61 2.89 434.72 428.97\" height=\"20\" width=\"20\"\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" fill=\"#FFF\" d=\"M216.412 11.432c114.637.024 208.732 92.935 208.588 205.963-.146 114.745-93.856 206.367-210.985 206.285C99.504 423.599 6.92 330.592 7 215.719c.079-112.328 94.369-204.311 209.412-204.287zm-63.368 72.341c2.628 12.861.075 24.855-3.811 36.653-2.691 8.17-6.411 16.036-8.632 24.317-3.66 13.644-7.813 27.369-9.336 41.324-2.19 20.067 5.743 37.741 19.317 55.316l-62.396-13.06c.109 1.96-.007 2.702.208 3.331 5.914 17.272 16.322 31.824 27.988 45.541 1.234 1.451 4.045 2.197 6.126 2.201 62.214.114 124.428.108 186.642.028 1.93-.002 4.505-.365 5.689-1.603 13.335-13.936 23.531-29.806 29.906-49.802l-66.055 12.859c4.357-8.489 9.331-15.954 12.19-24.156 9.78-28.058 5.726-55.186-8.311-80.771-11.266-20.532-21.657-40.975-16.037-65.72-11.896 11.679-16.465 26.548-19.364 41.871-2.856 15.092-4.539 30.406-6.75 45.718-.314-.462-.722-.804-.785-1.201-.256-1.607-.494-3.226-.581-4.848-1.343-25.081-6.271-49.246-16.671-72.326-6.122-13.586-12.873-27.476-6.562-43.682-4.271 2.239-8.13 4.464-10.897 7.641-8.258 9.482-11.673 20.871-12.551 33.341-.751 10.653-1.779 21.357-3.766 31.833-2.088 11.008-5.399 21.799-12.838 31.917-3.009-21.616-3.342-42.991-22.723-56.722zm160.411 214.562H118.323v33.699h195.132v-33.699zm-156.441 51.108c-.161 28.061 28.59 48.967 64.123 47.45 29.447-1.257 55.509-24.289 53.268-47.45H157.014z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n"},"model":{"name":"prometheus","version":"7.0.59","displayName":"Prometheus","category":{"name":"Observability and Analysis","metadata":null},"metadata":{"svgColor":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003c!DOCTYPE svg\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" role=\"img\" viewBox=\"-3.94 -1.44 438.62 432.87\" height=\"20\" width=\"20\"\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" fill=\"#E75225\" d=\"M215.926 7.068c115.684.024 210.638 93.784 210.493 207.844-.148 115.793-94.713 208.252-212.912 208.169C97.95 423 4.52 329.143 4.601 213.221 4.68 99.867 99.833 7.044 215.926 7.068zm-63.947 73.001c2.652 12.978.076 25.082-3.846 36.988-2.716 8.244-6.47 16.183-8.711 24.539-3.694 13.769-7.885 27.619-9.422 41.701-2.21 20.25 5.795 38.086 19.493 55.822L86.527 225.94c.11 1.978-.007 2.727.21 3.361 5.968 17.43 16.471 32.115 28.243 45.957 1.246 1.465 4.082 2.217 6.182 2.221 62.782.115 125.565.109 188.347.028 1.948-.003 4.546-.369 5.741-1.618 13.456-14.063 23.746-30.079 30.179-50.257l-66.658 12.976c4.397-8.567 9.417-16.1 12.302-24.377 9.869-28.315 5.779-55.69-8.387-81.509-11.368-20.72-21.854-41.349-16.183-66.32-12.005 11.786-16.615 26.79-19.541 42.253-2.882 15.23-4.58 30.684-6.811 46.136-.317-.467-.728-.811-.792-1.212-.258-1.621-.499-3.255-.587-4.893-1.355-25.31-6.328-49.696-16.823-72.987-6.178-13.71-12.99-27.727-6.622-44.081-4.31 2.259-8.205 4.505-10.997 7.711-8.333 9.569-11.779 21.062-12.666 33.645-.757 10.75-1.796 21.552-3.801 32.123-2.107 11.109-5.448 21.998-12.956 32.209-3.033-21.81-3.37-43.38-22.928-57.237zm161.877 216.523H116.942v34.007h196.914v-34.007zm-157.871 51.575c-.163 28.317 28.851 49.414 64.709 47.883 29.716-1.269 56.016-24.51 53.755-47.883H155.985z\"\u003e\u003c/path\u003e\u003c/svg\u003e","svgWhite":"\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\u003c!DOCTYPE svg\u003e\u003csvg xmlns=\"http://www.w3.org/2000/svg\" role=\"img\" viewBox=\"-1.61 2.89 434.72 428.97\" height=\"20\" width=\"20\"\u003e\u003cpath xmlns=\"http://www.w3.org/2000/svg\" fill=\"#FFF\" d=\"M216.412 11.432c114.637.024 208.732 92.935 208.588 205.963-.146 114.745-93.856 206.367-210.985 206.285C99.504 423.599 6.92 330.592 7 215.719c.079-112.328 94.369-204.311 209.412-204.287zm-63.368 72.341c2.628 12.861.075 24.855-3.811 36.653-2.691 8.17-6.411 16.036-8.632 24.317-3.66 13.644-7.813 27.369-9.336 41.324-2.19 20.067 5.743 37.741 19.317 55.316l-62.396-13.06c.109 1.96-.007 2.702.208 3.331 5.914 17.272 16.322 31.824 27.988 45.541 1.234 1.451 4.045 2.197 6.126 2.201 62.214.114 124.428.108 186.642.028 1.93-.002 4.505-.365 5.689-1.603 13.335-13.936 23.531-29.806 29.906-49.802l-66.055 12.859c4.357-8.489 9.331-15.954 12.19-24.156 9.78-28.058 5.726-55.186-8.311-80.771-11.266-20.532-21.657-40.975-16.037-65.72-11.896 11.679-16.465 26.548-19.364 41.871-2.856 15.092-4.539 30.406-6.75 45.718-.314-.462-.722-.804-.785-1.201-.256-1.607-.494-3.226-.581-4.848-1.343-25.081-6.271-49.246-16.671-72.326-6.122-13.586-12.873-27.476-6.562-43.682-4.271 2.239-8.13 4.464-10.897 7.641-8.258 9.482-11.673 20.871-12.551 33.341-.751 10.653-1.779 21.357-3.766 31.833-2.088 11.008-5.399 21.799-12.838 31.917-3.009-21.616-3.342-42.991-22.723-56.722zm160.411 214.562H118.323v33.699h195.132v-33.699zm-156.441 51.108c-.161 28.061 28.59 48.967 64.123 47.45 29.447-1.257 55.509-24.289 53.268-47.45H157.014z\"\u003e\u003c/path\u003e\u003c/svg\u003e\n"}},"schema":"{\n \"description\": \"Specification of the desired behavior of the cluster. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\",\n \"properties\": {\n  \"affinity\": {\n   \"description\": \"Affinity/Anti-affinity rules for Pods\",\n   \"properties\": {\n    \"additionalPodAffinity\": {\n     \"description\": \"AdditionalPodAffinity allows to specify pod affinity terms to be passed to all the cluster's pods.\",\n     \"properties\": {\n      \"preferredDuringSchedulingIgnoredDuringExecution\": {\n       \"description\": \"The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\\"weight\\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.\",\n       \"items\": {\n        \"description\": \"The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)\",\n        \"properties\": {\n         \"podAffinityTerm\": {\n          \"description\": \"Required. A pod affinity term, associated with the corresponding weight.\",\n          \"properties\": {\n           \"labelSelector\": {\n            \"description\": \"A label query over a set of resources, in this case pods.\",\n            \"properties\": {\n             \"matchExpressions\": {\n              \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n              \"items\": {\n               \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n               \"properties\": {\n                \"key\": {\n                 \"description\": \"key is the label key that the selector applies to.\",\n                 \"type\": \"string\"\n                },\n                \"operator\": {\n                 \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n                 \"type\": \"string\"\n                },\n                \"values\": {\n                 \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"required\": [\n                \"key\",\n                \"operator\"\n               ],\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             },\n             \"matchLabels\": {\n              \"additionalProperties\": {\n               \"type\": \"string\"\n              },\n              \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n              \"type\": \"object\"\n             }\n            },\n            \"type\": \"object\",\n            \"x-kubernetes-map-type\": \"atomic\"\n           },\n           \"namespaceSelector\": {\n            \"description\": \"A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means \\\"this pod's namespace\\\". An empty selector ({}) matches all namespaces.\",\n            \"properties\": {\n             \"matchExpressions\": {\n              \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n              \"items\": {\n               \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n               \"properties\": {\n                \"key\": {\n                 \"description\": \"key is the label key that the selector applies to.\",\n                 \"type\": \"string\"\n                },\n                \"operator\": {\n                 \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n                 \"type\": \"string\"\n                },\n                \"values\": {\n                 \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"required\": [\n                \"key\",\n                \"operator\"\n               ],\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             },\n             \"matchLabels\": {\n              \"additionalProperties\": {\n               \"type\": \"string\"\n              },\n              \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n              \"type\": \"object\"\n             }\n            },\n            \"type\": \"object\",\n            \"x-kubernetes-map-type\": \"atomic\"\n           },\n           \"namespaces\": {\n            \"description\": \"namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\\"this pod's namespace\\\".\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           },\n           \"topologyKey\": {\n            \"description\": \"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"topologyKey\"\n          ],\n          \"type\": \"object\"\n         },\n         \"weight\": {\n          \"description\": \"weight associated with matching the corresponding podAffinityTerm, in the range 1-100.\",\n          \"format\": \"int32\",\n          \"type\": \"integer\"\n         }\n        },\n        \"required\": [\n         \"podAffinityTerm\",\n         \"weight\"\n        ],\n        \"type\": \"object\"\n       },\n       \"type\": \"array\"\n      },\n      \"requiredDuringSchedulingIgnoredDuringExecution\": {\n       \"description\": \"If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.\",\n       \"items\": {\n        \"description\": \"Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key \\u003ctopologyKey\\u003e matches that of any node on which a pod of the set of pods is running\",\n        \"properties\": {\n         \"labelSelector\": {\n          \"description\": \"A label query over a set of resources, in this case pods.\",\n          \"properties\": {\n           \"matchExpressions\": {\n            \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n            \"items\": {\n             \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n             \"properties\": {\n              \"key\": {\n               \"description\": \"key is the label key that the selector applies to.\",\n               \"type\": \"string\"\n              },\n              \"operator\": {\n               \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n               \"type\": \"string\"\n              },\n              \"values\": {\n               \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n               \"items\": {\n                \"type\": \"string\"\n               },\n               \"type\": \"array\"\n              }\n             },\n             \"required\": [\n              \"key\",\n              \"operator\"\n             ],\n             \"type\": \"object\"\n            },\n            \"type\": \"array\"\n           },\n           \"matchLabels\": {\n            \"additionalProperties\": {\n             \"type\": \"string\"\n            },\n            \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n            \"type\": \"object\"\n           }\n          },\n          \"type\": \"object\",\n          \"x-kubernetes-map-type\": \"atomic\"\n         },\n         \"namespaceSelector\": {\n          \"description\": \"A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means \\\"this pod's namespace\\\". An empty selector ({}) matches all namespaces.\",\n          \"properties\": {\n           \"matchExpressions\": {\n            \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n            \"items\": {\n             \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n             \"properties\": {\n              \"key\": {\n               \"description\": \"key is the label key that the selector applies to.\",\n               \"type\": \"string\"\n              },\n              \"operator\": {\n               \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n               \"type\": \"string\"\n              },\n              \"values\": {\n               \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n               \"items\": {\n                \"type\": \"string\"\n               },\n               \"type\": \"array\"\n              }\n             },\n             \"required\": [\n              \"key\",\n              \"operator\"\n             ],\n             \"type\": \"object\"\n            },\n            \"type\": \"array\"\n           },\n           \"matchLabels\": {\n            \"additionalProperties\": {\n             \"type\": \"string\"\n            },\n            \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n            \"type\": \"object\"\n           }\n          },\n          \"type\": \"object\",\n          \"x-kubernetes-map-type\": \"atomic\"\n         },\n         \"namespaces\": {\n          \"description\": \"namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\\"this pod's namespace\\\".\",\n          \"items\": {\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         },\n         \"topologyKey\": {\n          \"description\": \"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\n          \"type\": \"string\"\n         }\n        },\n        \"required\": [\n         \"topologyKey\"\n        ],\n        \"type\": \"object\"\n       },\n       \"type\": \"array\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"additionalPodAntiAffinity\": {\n     \"description\": \"AdditionalPodAntiAffinity allows to specify pod anti-affinity terms to be added to the ones generated by the operator if EnablePodAntiAffinity is set to true (default) or to be used exclusively if set to false.\",\n     \"properties\": {\n      \"preferredDuringSchedulingIgnoredDuringExecution\": {\n       \"description\": \"The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\\"weight\\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.\",\n       \"items\": {\n        \"description\": \"The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)\",\n        \"properties\": {\n         \"podAffinityTerm\": {\n          \"description\": \"Required. A pod affinity term, associated with the corresponding weight.\",\n          \"properties\": {\n           \"labelSelector\": {\n            \"description\": \"A label query over a set of resources, in this case pods.\",\n            \"properties\": {\n             \"matchExpressions\": {\n              \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n              \"items\": {\n               \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n               \"properties\": {\n                \"key\": {\n                 \"description\": \"key is the label key that the selector applies to.\",\n                 \"type\": \"string\"\n                },\n                \"operator\": {\n                 \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n                 \"type\": \"string\"\n                },\n                \"values\": {\n                 \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"required\": [\n                \"key\",\n                \"operator\"\n               ],\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             },\n             \"matchLabels\": {\n              \"additionalProperties\": {\n               \"type\": \"string\"\n              },\n              \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n              \"type\": \"object\"\n             }\n            },\n            \"type\": \"object\",\n            \"x-kubernetes-map-type\": \"atomic\"\n           },\n           \"namespaceSelector\": {\n            \"description\": \"A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means \\\"this pod's namespace\\\". An empty selector ({}) matches all namespaces.\",\n            \"properties\": {\n             \"matchExpressions\": {\n              \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n              \"items\": {\n               \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n               \"properties\": {\n                \"key\": {\n                 \"description\": \"key is the label key that the selector applies to.\",\n                 \"type\": \"string\"\n                },\n                \"operator\": {\n                 \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n                 \"type\": \"string\"\n                },\n                \"values\": {\n                 \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n                 \"items\": {\n                  \"type\": \"string\"\n                 },\n                 \"type\": \"array\"\n                }\n               },\n               \"required\": [\n                \"key\",\n                \"operator\"\n               ],\n               \"type\": \"object\"\n              },\n              \"type\": \"array\"\n             },\n             \"matchLabels\": {\n              \"additionalProperties\": {\n               \"type\": \"string\"\n              },\n              \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n              \"type\": \"object\"\n             }\n            },\n            \"type\": \"object\",\n            \"x-kubernetes-map-type\": \"atomic\"\n           },\n           \"namespaces\": {\n            \"description\": \"namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\\"this pod's namespace\\\".\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           },\n           \"topologyKey\": {\n            \"description\": \"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"topologyKey\"\n          ],\n          \"type\": \"object\"\n         },\n         \"weight\": {\n          \"description\": \"weight associated with matching the corresponding podAffinityTerm, in the range 1-100.\",\n          \"format\": \"int32\",\n          \"type\": \"integer\"\n         }\n        },\n        \"required\": [\n         \"podAffinityTerm\",\n         \"weight\"\n        ],\n        \"type\": \"object\"\n       },\n       \"type\": \"array\"\n      },\n      \"requiredDuringSchedulingIgnoredDuringExecution\": {\n       \"description\": \"If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.\",\n       \"items\": {\n        \"description\": \"Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key \\u003ctopologyKey\\u003e matches that of any node on which a pod of the set of pods is running\",\n        \"properties\": {\n         \"labelSelector\": {\n          \"description\": \"A label query over a set of resources, in this case pods.\",\n          \"properties\": {\n           \"matchExpressions\": {\n            \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n            \"items\": {\n             \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n             \"properties\": {\n              \"key\": {\n               \"description\": \"key is the label key that the selector applies to.\",\n               \"type\": \"string\"\n              },\n              \"operator\": {\n               \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n               \"type\": \"string\"\n              },\n              \"values\": {\n               \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n               \"items\": {\n                \"type\": \"string\"\n               },\n               \"type\": \"array\"\n              }\n             },\n             \"required\": [\n              \"key\",\n              \"operator\"\n             ],\n             \"type\": \"object\"\n            },\n            \"type\": \"array\"\n           },\n           \"matchLabels\": {\n            \"additionalProperties\": {\n             \"type\": \"string\"\n            },\n            \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n            \"type\": \"object\"\n           }\n          },\n          \"type\": \"object\",\n          \"x-kubernetes-map-type\": \"atomic\"\n         },\n         \"namespaceSelector\": {\n          \"description\": \"A label query over the set of namespaces that the term applies to. The term is applied to the union of the namespaces selected by this field and the ones listed in the namespaces field. null selector and null or empty namespaces list means \\\"this pod's namespace\\\". An empty selector ({}) matches all namespaces.\",\n          \"properties\": {\n           \"matchExpressions\": {\n            \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n            \"items\": {\n             \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n             \"properties\": {\n              \"key\": {\n               \"description\": \"key is the label key that the selector applies to.\",\n               \"type\": \"string\"\n              },\n              \"operator\": {\n               \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n               \"type\": \"string\"\n              },\n              \"values\": {\n               \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n               \"items\": {\n                \"type\": \"string\"\n               },\n               \"type\": \"array\"\n              }\n             },\n             \"required\": [\n              \"key\",\n              \"operator\"\n             ],\n             \"type\": \"object\"\n            },\n            \"type\": \"array\"\n           },\n           \"matchLabels\": {\n            \"additionalProperties\": {\n             \"type\": \"string\"\n            },\n            \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n            \"type\": \"object\"\n           }\n          },\n          \"type\": \"object\",\n          \"x-kubernetes-map-type\": \"atomic\"\n         },\n         \"namespaces\": {\n          \"description\": \"namespaces specifies a static list of namespace names that the term applies to. The term is applied to the union of the namespaces listed in this field and the ones selected by namespaceSelector. null or empty namespaces list and null namespaceSelector means \\\"this pod's namespace\\\".\",\n          \"items\": {\n           \"type\": \"string\"\n          },\n          \"type\": \"array\"\n         },\n         \"topologyKey\": {\n          \"description\": \"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\n          \"type\": \"string\"\n         }\n        },\n        \"required\": [\n         \"topologyKey\"\n        ],\n        \"type\": \"object\"\n       },\n       \"type\": \"array\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"enablePodAntiAffinity\": {\n     \"description\": \"Activates anti-affinity for the pods. The operator will define pods anti-affinity unless this field is explicitly set to false\",\n     \"type\": \"boolean\"\n    },\n    \"nodeSelector\": {\n     \"additionalProperties\": {\n      \"type\": \"string\"\n     },\n     \"description\": \"NodeSelector is map of key-value pairs used to define the nodes on which the pods can run. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/\",\n     \"type\": \"object\"\n    },\n    \"podAntiAffinityType\": {\n     \"description\": \"PodAntiAffinityType allows the user to decide whether pod anti-affinity between cluster instance has to be considered a strong requirement during scheduling or not. Allowed values are: \\\"preferred\\\" (default if empty) or \\\"required\\\". Setting it to \\\"required\\\", could lead to instances remaining pending until new kubernetes nodes are added if all the existing nodes don't match the required pod anti-affinity rule. More info: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity\",\n     \"type\": \"string\"\n    },\n    \"tolerations\": {\n     \"description\": \"Tolerations is a list of Tolerations that should be set for all the pods, in order to allow them to run on tainted nodes. More info: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/\",\n     \"items\": {\n      \"description\": \"The pod this Toleration is attached to tolerates any taint that matches the triple \\u003ckey,value,effect\\u003e using the matching operator \\u003coperator\\u003e.\",\n      \"properties\": {\n       \"effect\": {\n        \"description\": \"Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.\",\n        \"type\": \"string\"\n       },\n       \"key\": {\n        \"description\": \"Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.\",\n        \"type\": \"string\"\n       },\n       \"operator\": {\n        \"description\": \"Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.\",\n        \"type\": \"string\"\n       },\n       \"tolerationSeconds\": {\n        \"description\": \"TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.\",\n        \"format\": \"int64\",\n        \"type\": \"integer\"\n       },\n       \"value\": {\n        \"description\": \"Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.\",\n        \"type\": \"string\"\n       }\n      },\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    },\n    \"topologyKey\": {\n     \"description\": \"TopologyKey to use for anti-affinity configuration. See k8s documentation for more info on that\",\n     \"type\": \"string\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"backup\": {\n   \"description\": \"The configuration to be used for backups\",\n   \"properties\": {\n    \"barmanObjectStore\": {\n     \"description\": \"The configuration for the barman-cloud tool suite\",\n     \"properties\": {\n      \"azureCredentials\": {\n       \"description\": \"The credentials to use to upload data to Azure Blob Storage\",\n       \"properties\": {\n        \"connectionString\": {\n         \"description\": \"The connection string to be used\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key to select\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent.\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"key\",\n          \"name\"\n         ],\n         \"type\": \"object\"\n        },\n        \"inheritFromAzureAD\": {\n         \"description\": \"Use the Azure AD based authentication without providing explicitly the keys.\",\n         \"type\": \"boolean\"\n        },\n        \"storageAccount\": {\n         \"description\": \"The storage account where to upload data\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key to select\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent.\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"key\",\n          \"name\"\n         ],\n         \"type\": \"object\"\n        },\n        \"storageKey\": {\n         \"description\": \"The storage account key to be used in conjunction with the storage account name\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key to select\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent.\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"key\",\n          \"name\"\n         ],\n         \"type\": \"object\"\n        },\n        \"storageSasToken\": {\n         \"description\": \"A shared-access-signature to be used in conjunction with the storage account name\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key to select\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent.\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"key\",\n          \"name\"\n         ],\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"data\": {\n       \"description\": \"The configuration to be used to backup the data files When not defined, base backups files will be stored uncompressed and may be unencrypted in the object store, according to the bucket default policy.\",\n       \"properties\": {\n        \"compression\": {\n         \"description\": \"Compress a backup file (a tar file per tablespace) while streaming it to the object store. Available options are empty string (no compression, default), `gzip`, `bzip2` or `snappy`.\",\n         \"enum\": [\n          \"gzip\",\n          \"bzip2\",\n          \"snappy\"\n         ],\n         \"type\": \"string\"\n        },\n        \"encryption\": {\n         \"description\": \"Whenever to force the encryption of files (if the bucket is not already configured for that). Allowed options are empty string (use the bucket policy, default), `AES256` and `aws:kms`\",\n         \"enum\": [\n          \"AES256\",\n          \"aws:kms\"\n         ],\n         \"type\": \"string\"\n        },\n        \"immediateCheckpoint\": {\n         \"description\": \"Control whether the I/O workload for the backup initial checkpoint will be limited, according to the `checkpoint_completion_target` setting on the PostgreSQL server. If set to true, an immediate checkpoint will be used, meaning PostgreSQL will complete the checkpoint as soon as possible. `false` by default.\",\n         \"type\": \"boolean\"\n        },\n        \"jobs\": {\n         \"description\": \"The number of parallel jobs to be used to upload the backup, defaults to 2\",\n         \"format\": \"int32\",\n         \"minimum\": 1,\n         \"type\": \"integer\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"destinationPath\": {\n       \"description\": \"The path where to store the backup (i.e. s3://bucket/path/to/folder) this path, with different destination folders, will be used for WALs and for data\",\n       \"minLength\": 1,\n       \"type\": \"string\"\n      },\n      \"endpointCA\": {\n       \"description\": \"EndpointCA store the CA bundle of the barman endpoint. Useful when using self-signed certificates to avoid errors with certificate issuer and barman-cloud-wal-archive\",\n       \"properties\": {\n        \"key\": {\n         \"description\": \"The key to select\",\n         \"type\": \"string\"\n        },\n        \"name\": {\n         \"description\": \"Name of the referent.\",\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"key\",\n        \"name\"\n       ],\n       \"type\": \"object\"\n      },\n      \"endpointURL\": {\n       \"description\": \"Endpoint to be used to upload data to the cloud, overriding the automatic endpoint discovery\",\n       \"type\": \"string\"\n      },\n      \"googleCredentials\": {\n       \"description\": \"The credentials to use to upload data to Google Cloud Storage\",\n       \"properties\": {\n        \"applicationCredentials\": {\n         \"description\": \"The secret containing the Google Cloud Storage JSON file with the credentials\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key to select\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent.\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"key\",\n          \"name\"\n         ],\n         \"type\": \"object\"\n        },\n        \"gkeEnvironment\": {\n         \"description\": \"If set to true, will presume that it's running inside a GKE environment, default to false.\",\n         \"type\": \"boolean\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"historyTags\": {\n       \"additionalProperties\": {\n        \"type\": \"string\"\n       },\n       \"description\": \"HistoryTags is a list of key value pairs that will be passed to the Barman --history-tags option.\",\n       \"type\": \"object\"\n      },\n      \"s3Credentials\": {\n       \"description\": \"The credentials to use to upload data to S3\",\n       \"properties\": {\n        \"accessKeyId\": {\n         \"description\": \"The reference to the access key id\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key to select\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent.\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"key\",\n          \"name\"\n         ],\n         \"type\": \"object\"\n        },\n        \"inheritFromIAMRole\": {\n         \"description\": \"Use the role based authentication without providing explicitly the keys.\",\n         \"type\": \"boolean\"\n        },\n        \"region\": {\n         \"description\": \"The reference to the secret containing the region name\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key to select\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent.\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"key\",\n          \"name\"\n         ],\n         \"type\": \"object\"\n        },\n        \"secretAccessKey\": {\n         \"description\": \"The reference to the secret access key\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key to select\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent.\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"key\",\n          \"name\"\n         ],\n         \"type\": \"object\"\n        },\n        \"sessionToken\": {\n         \"description\": \"The references to the session key\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key to select\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent.\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"key\",\n          \"name\"\n         ],\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"serverName\": {\n       \"description\": \"The server name on S3, the cluster name is used if this parameter is omitted\",\n       \"type\": \"string\"\n      },\n      \"tags\": {\n       \"additionalProperties\": {\n        \"type\": \"string\"\n       },\n       \"description\": \"Tags is a list of key value pairs that will be passed to the Barman --tags option.\",\n       \"type\": \"object\"\n      },\n      \"wal\": {\n       \"description\": \"The configuration for the backup of the WAL stream. When not defined, WAL files will be stored uncompressed and may be unencrypted in the object store, according to the bucket default policy.\",\n       \"properties\": {\n        \"compression\": {\n         \"description\": \"Compress a WAL file before sending it to the object store. Available options are empty string (no compression, default), `gzip`, `bzip2` or `snappy`.\",\n         \"enum\": [\n          \"gzip\",\n          \"bzip2\",\n          \"snappy\"\n         ],\n         \"type\": \"string\"\n        },\n        \"encryption\": {\n         \"description\": \"Whenever to force the encryption of files (if the bucket is not already configured for that). Allowed options are empty string (use the bucket policy, default), `AES256` and `aws:kms`\",\n         \"enum\": [\n          \"AES256\",\n          \"aws:kms\"\n         ],\n         \"type\": \"string\"\n        },\n        \"maxParallel\": {\n         \"description\": \"Number of WAL files to be either archived in parallel (when the PostgreSQL instance is archiving to a backup object store) or restored in parallel (when a PostgreSQL standby is fetching WAL files from a recovery object store). If not specified, WAL files will be processed one at a time. It accepts a positive integer as a value - with 1 being the minimum accepted value.\",\n         \"minimum\": 1,\n         \"type\": \"integer\"\n        }\n       },\n       \"type\": \"object\"\n      }\n     },\n     \"required\": [\n      \"destinationPath\"\n     ],\n     \"type\": \"object\"\n    },\n    \"retentionPolicy\": {\n     \"description\": \"RetentionPolicy is the retention policy to be used for backups and WALs (i.e. '60d'). The retention policy is expressed in the form of `XXu` where `XX` is a positive integer and `u` is in `[dwm]` - days, weeks, months.\",\n     \"pattern\": \"^[1-9][0-9]*[dwm]$\",\n     \"type\": \"string\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"bootstrap\": {\n   \"description\": \"Instructions to bootstrap this cluster\",\n   \"properties\": {\n    \"initdb\": {\n     \"description\": \"Bootstrap the cluster via initdb\",\n     \"properties\": {\n      \"dataChecksums\": {\n       \"description\": \"Whether the `-k` option should be passed to initdb, enabling checksums on data pages (default: `false`)\",\n       \"type\": \"boolean\"\n      },\n      \"database\": {\n       \"description\": \"Name of the database used by the application. Default: `app`.\",\n       \"type\": \"string\"\n      },\n      \"encoding\": {\n       \"description\": \"The value to be passed as option `--encoding` for initdb (default:`UTF8`)\",\n       \"type\": \"string\"\n      },\n      \"import\": {\n       \"description\": \"Bootstraps the new cluster by importing data from an existing PostgreSQL instance using logical backup (`pg_dump` and `pg_restore`)\",\n       \"properties\": {\n        \"databases\": {\n         \"description\": \"The databases to import\",\n         \"items\": {\n          \"type\": \"string\"\n         },\n         \"type\": \"array\"\n        },\n        \"postImportApplicationSQL\": {\n         \"description\": \"List of SQL queries to be executed as a superuser in the application database right after is imported - to be used with extreme care (by default empty). Only available in microservice type.\",\n         \"items\": {\n          \"type\": \"string\"\n         },\n         \"type\": \"array\"\n        },\n        \"roles\": {\n         \"description\": \"The roles to import\",\n         \"items\": {\n          \"type\": \"string\"\n         },\n         \"type\": \"array\"\n        },\n        \"source\": {\n         \"description\": \"The source of the import\",\n         \"properties\": {\n          \"externalCluster\": {\n           \"description\": \"The name of the externalCluster used for import\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"externalCluster\"\n         ],\n         \"type\": \"object\"\n        },\n        \"type\": {\n         \"description\": \"The import type. Can be `microservice` or `monolith`.\",\n         \"enum\": [\n          \"microservice\",\n          \"monolith\"\n         ],\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"databases\",\n        \"source\",\n        \"type\"\n       ],\n       \"type\": \"object\"\n      },\n      \"localeCType\": {\n       \"description\": \"The value to be passed as option `--lc-ctype` for initdb (default:`C`)\",\n       \"type\": \"string\"\n      },\n      \"localeCollate\": {\n       \"description\": \"The value to be passed as option `--lc-collate` for initdb (default:`C`)\",\n       \"type\": \"string\"\n      },\n      \"options\": {\n       \"description\": \"The list of options that must be passed to initdb when creating the cluster. Deprecated: This could lead to inconsistent configurations, please use the explicit provided parameters instead. If defined, explicit values will be ignored.\",\n       \"items\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"array\"\n      },\n      \"owner\": {\n       \"description\": \"Name of the owner of the database in the instance to be used by applications. Defaults to the value of the `database` key.\",\n       \"type\": \"string\"\n      },\n      \"postInitApplicationSQL\": {\n       \"description\": \"List of SQL queries to be executed as a superuser in the application database right after is created - to be used with extreme care (by default empty)\",\n       \"items\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"array\"\n      },\n      \"postInitApplicationSQLRefs\": {\n       \"description\": \"PostInitApplicationSQLRefs points references to ConfigMaps or Secrets which contain SQL files, the general implementation order to these references is from all Secrets to all ConfigMaps, and inside Secrets or ConfigMaps, the implementation order is same as the order of each array (by default empty)\",\n       \"properties\": {\n        \"configMapRefs\": {\n         \"description\": \"ConfigMapRefs holds a list of references to ConfigMaps\",\n         \"items\": {\n          \"description\": \"ConfigMapKeySelector contains enough information to let you locate the key of a ConfigMap\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         },\n         \"type\": \"array\"\n        },\n        \"secretRefs\": {\n         \"description\": \"SecretRefs holds a list of references to Secrets\",\n         \"items\": {\n          \"description\": \"SecretKeySelector contains enough information to let you locate the key of a Secret\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         },\n         \"type\": \"array\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"postInitSQL\": {\n       \"description\": \"List of SQL queries to be executed as a superuser immediately after the cluster has been created - to be used with extreme care (by default empty)\",\n       \"items\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"array\"\n      },\n      \"postInitTemplateSQL\": {\n       \"description\": \"List of SQL queries to be executed as a superuser in the `template1` after the cluster has been created - to be used with extreme care (by default empty)\",\n       \"items\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"array\"\n      },\n      \"secret\": {\n       \"description\": \"Name of the secret containing the initial credentials for the owner of the user database. If empty a new secret will be created from scratch\",\n       \"properties\": {\n        \"name\": {\n         \"description\": \"Name of the referent.\",\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"name\"\n       ],\n       \"type\": \"object\"\n      },\n      \"walSegmentSize\": {\n       \"description\": \"The value in megabytes (1 to 1024) to be passed to the `--wal-segsize` option for initdb (default: empty, resulting in PostgreSQL default: 16MB)\",\n       \"maximum\": 1024,\n       \"minimum\": 1,\n       \"type\": \"integer\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"pg_basebackup\": {\n     \"description\": \"Bootstrap the cluster taking a physical backup of another compatible PostgreSQL instance\",\n     \"properties\": {\n      \"database\": {\n       \"description\": \"Name of the database used by the application. Default: `app`.\",\n       \"type\": \"string\"\n      },\n      \"owner\": {\n       \"description\": \"Name of the owner of the database in the instance to be used by applications. Defaults to the value of the `database` key.\",\n       \"type\": \"string\"\n      },\n      \"secret\": {\n       \"description\": \"Name of the secret containing the initial credentials for the owner of the user database. If empty a new secret will be created from scratch\",\n       \"properties\": {\n        \"name\": {\n         \"description\": \"Name of the referent.\",\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"name\"\n       ],\n       \"type\": \"object\"\n      },\n      \"source\": {\n       \"description\": \"The name of the server of which we need to take a physical backup\",\n       \"minLength\": 1,\n       \"type\": \"string\"\n      }\n     },\n     \"required\": [\n      \"source\"\n     ],\n     \"type\": \"object\"\n    },\n    \"recovery\": {\n     \"description\": \"Bootstrap the cluster from a backup\",\n     \"properties\": {\n      \"backup\": {\n       \"description\": \"The backup we need to restore\",\n       \"properties\": {\n        \"endpointCA\": {\n         \"description\": \"EndpointCA store the CA bundle of the barman endpoint. Useful when using self-signed certificates to avoid errors with certificate issuer and barman-cloud-wal-archive.\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key to select\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent.\",\n           \"type\": \"string\"\n          }\n         },\n         \"required\": [\n          \"key\",\n          \"name\"\n         ],\n         \"type\": \"object\"\n        },\n        \"name\": {\n         \"description\": \"Name of the referent.\",\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"name\"\n       ],\n       \"type\": \"object\"\n      },\n      \"database\": {\n       \"description\": \"Name of the database used by the application. Default: `app`.\",\n       \"type\": \"string\"\n      },\n      \"owner\": {\n       \"description\": \"Name of the owner of the database in the instance to be used by applications. Defaults to the value of the `database` key.\",\n       \"type\": \"string\"\n      },\n      \"recoveryTarget\": {\n       \"description\": \"By default, the recovery process applies all the available WAL files in the archive (full recovery). However, you can also end the recovery as soon as a consistent state is reached or recover to a point-in-time (PITR) by specifying a `RecoveryTarget` object, as expected by PostgreSQL (i.e., timestamp, transaction Id, LSN, ...). More info: https://www.postgresql.org/docs/current/runtime-config-wal.html#RUNTIME-CONFIG-WAL-RECOVERY-TARGET\",\n       \"properties\": {\n        \"backupID\": {\n         \"description\": \"The ID of the backup from which to start the recovery process. If empty (default) the operator will automatically detect the backup based on targetTime or targetLSN if specified. Otherwise use the latest available backup in chronological order.\",\n         \"type\": \"string\"\n        },\n        \"exclusive\": {\n         \"description\": \"Set the target to be exclusive (defaults to true)\",\n         \"type\": \"boolean\"\n        },\n        \"targetImmediate\": {\n         \"description\": \"End recovery as soon as a consistent state is reached\",\n         \"type\": \"boolean\"\n        },\n        \"targetLSN\": {\n         \"description\": \"The target LSN (Log Sequence Number)\",\n         \"type\": \"string\"\n        },\n        \"targetName\": {\n         \"description\": \"The target name (to be previously created with `pg_create_restore_point`)\",\n         \"type\": \"string\"\n        },\n        \"targetTLI\": {\n         \"description\": \"The target timeline (\\\"latest\\\" or a positive integer)\",\n         \"type\": \"string\"\n        },\n        \"targetTime\": {\n         \"description\": \"The target time as a timestamp in the RFC3339 standard\",\n         \"type\": \"string\"\n        },\n        \"targetXID\": {\n         \"description\": \"The target transaction ID\",\n         \"type\": \"string\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"secret\": {\n       \"description\": \"Name of the secret containing the initial credentials for the owner of the user database. If empty a new secret will be created from scratch\",\n       \"properties\": {\n        \"name\": {\n         \"description\": \"Name of the referent.\",\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"name\"\n       ],\n       \"type\": \"object\"\n      },\n      \"source\": {\n       \"description\": \"The external cluster whose backup we will restore. This is also used as the name of the folder under which the backup is stored, so it must be set to the name of the source cluster\",\n       \"type\": \"string\"\n      }\n     },\n     \"type\": \"object\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"certificates\": {\n   \"description\": \"The configuration for the CA and related certificates\",\n   \"properties\": {\n    \"clientCASecret\": {\n     \"description\": \"The secret containing the Client CA certificate. If not defined, a new secret will be created with a self-signed CA and will be used to generate all the client certificates.\\u003cbr /\\u003e \\u003cbr /\\u003e Contains:\\u003cbr /\\u003e \\u003cbr /\\u003e - `ca.crt`: CA that should be used to validate the client certificates, used as `ssl_ca_file` of all the instances.\\u003cbr /\\u003e - `ca.key`: key used to generate client certificates, if ReplicationTLSSecret is provided, this can be omitted.\\u003cbr /\\u003e\",\n     \"type\": \"string\"\n    },\n    \"replicationTLSSecret\": {\n     \"description\": \"The secret of type kubernetes.io/tls containing the client certificate to authenticate as the `streaming_replica` user. If not defined, ClientCASecret must provide also `ca.key`, and a new secret will be created using the provided CA.\",\n     \"type\": \"string\"\n    },\n    \"serverAltDNSNames\": {\n     \"description\": \"The list of the server alternative DNS names to be added to the generated server TLS certificates, when required.\",\n     \"items\": {\n      \"type\": \"string\"\n     },\n     \"type\": \"array\"\n    },\n    \"serverCASecret\": {\n     \"description\": \"The secret containing the Server CA certificate. If not defined, a new secret will be created with a self-signed CA and will be used to generate the TLS certificate ServerTLSSecret.\\u003cbr /\\u003e \\u003cbr /\\u003e Contains:\\u003cbr /\\u003e \\u003cbr /\\u003e - `ca.crt`: CA that should be used to validate the server certificate, used as `sslrootcert` in client connection strings.\\u003cbr /\\u003e - `ca.key`: key used to generate Server SSL certs, if ServerTLSSecret is provided, this can be omitted.\\u003cbr /\\u003e\",\n     \"type\": \"string\"\n    },\n    \"serverTLSSecret\": {\n     \"description\": \"The secret of type kubernetes.io/tls containing the server TLS certificate and key that will be set as `ssl_cert_file` and `ssl_key_file` so that clients can connect to postgres securely. If not defined, ServerCASecret must provide also `ca.key` and a new secret will be created using the provided CA.\",\n     \"type\": \"string\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"description\": {\n   \"description\": \"Description of this PostgreSQL cluster\",\n   \"type\": \"string\"\n  },\n  \"enableSuperuserAccess\": {\n   \"default\": true,\n   \"description\": \"When this option is enabled, the operator will use the `SuperuserSecret` to update the `postgres` user password (if the secret is not present, the operator will automatically create one). When this option is disabled, the operator will ignore the `SuperuserSecret` content, delete it when automatically created, and then blank the password of the `postgres` user by setting it to `NULL`. Enabled by default.\",\n   \"type\": \"boolean\"\n  },\n  \"externalClusters\": {\n   \"description\": \"The list of external clusters which are used in the configuration\",\n   \"items\": {\n    \"description\": \"ExternalCluster represents the connection parameters to an external cluster which is used in the other sections of the configuration\",\n    \"properties\": {\n     \"barmanObjectStore\": {\n      \"description\": \"The configuration for the barman-cloud tool suite\",\n      \"properties\": {\n       \"azureCredentials\": {\n        \"description\": \"The credentials to use to upload data to Azure Blob Storage\",\n        \"properties\": {\n         \"connectionString\": {\n          \"description\": \"The connection string to be used\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         },\n         \"inheritFromAzureAD\": {\n          \"description\": \"Use the Azure AD based authentication without providing explicitly the keys.\",\n          \"type\": \"boolean\"\n         },\n         \"storageAccount\": {\n          \"description\": \"The storage account where to upload data\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         },\n         \"storageKey\": {\n          \"description\": \"The storage account key to be used in conjunction with the storage account name\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         },\n         \"storageSasToken\": {\n          \"description\": \"A shared-access-signature to be used in conjunction with the storage account name\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"data\": {\n        \"description\": \"The configuration to be used to backup the data files When not defined, base backups files will be stored uncompressed and may be unencrypted in the object store, according to the bucket default policy.\",\n        \"properties\": {\n         \"compression\": {\n          \"description\": \"Compress a backup file (a tar file per tablespace) while streaming it to the object store. Available options are empty string (no compression, default), `gzip`, `bzip2` or `snappy`.\",\n          \"enum\": [\n           \"gzip\",\n           \"bzip2\",\n           \"snappy\"\n          ],\n          \"type\": \"string\"\n         },\n         \"encryption\": {\n          \"description\": \"Whenever to force the encryption of files (if the bucket is not already configured for that). Allowed options are empty string (use the bucket policy, default), `AES256` and `aws:kms`\",\n          \"enum\": [\n           \"AES256\",\n           \"aws:kms\"\n          ],\n          \"type\": \"string\"\n         },\n         \"immediateCheckpoint\": {\n          \"description\": \"Control whether the I/O workload for the backup initial checkpoint will be limited, according to the `checkpoint_completion_target` setting on the PostgreSQL server. If set to true, an immediate checkpoint will be used, meaning PostgreSQL will complete the checkpoint as soon as possible. `false` by default.\",\n          \"type\": \"boolean\"\n         },\n         \"jobs\": {\n          \"description\": \"The number of parallel jobs to be used to upload the backup, defaults to 2\",\n          \"format\": \"int32\",\n          \"minimum\": 1,\n          \"type\": \"integer\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"destinationPath\": {\n        \"description\": \"The path where to store the backup (i.e. s3://bucket/path/to/folder) this path, with different destination folders, will be used for WALs and for data\",\n        \"minLength\": 1,\n        \"type\": \"string\"\n       },\n       \"endpointCA\": {\n        \"description\": \"EndpointCA store the CA bundle of the barman endpoint. Useful when using self-signed certificates to avoid errors with certificate issuer and barman-cloud-wal-archive\",\n        \"properties\": {\n         \"key\": {\n          \"description\": \"The key to select\",\n          \"type\": \"string\"\n         },\n         \"name\": {\n          \"description\": \"Name of the referent.\",\n          \"type\": \"string\"\n         }\n        },\n        \"required\": [\n         \"key\",\n         \"name\"\n        ],\n        \"type\": \"object\"\n       },\n       \"endpointURL\": {\n        \"description\": \"Endpoint to be used to upload data to the cloud, overriding the automatic endpoint discovery\",\n        \"type\": \"string\"\n       },\n       \"googleCredentials\": {\n        \"description\": \"The credentials to use to upload data to Google Cloud Storage\",\n        \"properties\": {\n         \"applicationCredentials\": {\n          \"description\": \"The secret containing the Google Cloud Storage JSON file with the credentials\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         },\n         \"gkeEnvironment\": {\n          \"description\": \"If set to true, will presume that it's running inside a GKE environment, default to false.\",\n          \"type\": \"boolean\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"historyTags\": {\n        \"additionalProperties\": {\n         \"type\": \"string\"\n        },\n        \"description\": \"HistoryTags is a list of key value pairs that will be passed to the Barman --history-tags option.\",\n        \"type\": \"object\"\n       },\n       \"s3Credentials\": {\n        \"description\": \"The credentials to use to upload data to S3\",\n        \"properties\": {\n         \"accessKeyId\": {\n          \"description\": \"The reference to the access key id\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         },\n         \"inheritFromIAMRole\": {\n          \"description\": \"Use the role based authentication without providing explicitly the keys.\",\n          \"type\": \"boolean\"\n         },\n         \"region\": {\n          \"description\": \"The reference to the secret containing the region name\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         },\n         \"secretAccessKey\": {\n          \"description\": \"The reference to the secret access key\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         },\n         \"sessionToken\": {\n          \"description\": \"The references to the session key\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"The key to select\",\n            \"type\": \"string\"\n           },\n           \"name\": {\n            \"description\": \"Name of the referent.\",\n            \"type\": \"string\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"name\"\n          ],\n          \"type\": \"object\"\n         }\n        },\n        \"type\": \"object\"\n       },\n       \"serverName\": {\n        \"description\": \"The server name on S3, the cluster name is used if this parameter is omitted\",\n        \"type\": \"string\"\n       },\n       \"tags\": {\n        \"additionalProperties\": {\n         \"type\": \"string\"\n        },\n        \"description\": \"Tags is a list of key value pairs that will be passed to the Barman --tags option.\",\n        \"type\": \"object\"\n       },\n       \"wal\": {\n        \"description\": \"The configuration for the backup of the WAL stream. When not defined, WAL files will be stored uncompressed and may be unencrypted in the object store, according to the bucket default policy.\",\n        \"properties\": {\n         \"compression\": {\n          \"description\": \"Compress a WAL file before sending it to the object store. Available options are empty string (no compression, default), `gzip`, `bzip2` or `snappy`.\",\n          \"enum\": [\n           \"gzip\",\n           \"bzip2\",\n           \"snappy\"\n          ],\n          \"type\": \"string\"\n         },\n         \"encryption\": {\n          \"description\": \"Whenever to force the encryption of files (if the bucket is not already configured for that). Allowed options are empty string (use the bucket policy, default), `AES256` and `aws:kms`\",\n          \"enum\": [\n           \"AES256\",\n           \"aws:kms\"\n          ],\n          \"type\": \"string\"\n         },\n         \"maxParallel\": {\n          \"description\": \"Number of WAL files to be either archived in parallel (when the PostgreSQL instance is archiving to a backup object store) or restored in parallel (when a PostgreSQL standby is fetching WAL files from a recovery object store). If not specified, WAL files will be processed one at a time. It accepts a positive integer as a value - with 1 being the minimum accepted value.\",\n          \"minimum\": 1,\n          \"type\": \"integer\"\n         }\n        },\n        \"type\": \"object\"\n       }\n      },\n      \"required\": [\n       \"destinationPath\"\n      ],\n      \"type\": \"object\"\n     },\n     \"connectionParameters\": {\n      \"additionalProperties\": {\n       \"type\": \"string\"\n      },\n      \"description\": \"The list of connection parameters, such as dbname, host, username, etc\",\n      \"type\": \"object\"\n     },\n     \"name\": {\n      \"description\": \"The server name, required\",\n      \"type\": \"string\"\n     },\n     \"password\": {\n      \"description\": \"The reference to the password to be used to connect to the server\",\n      \"properties\": {\n       \"key\": {\n        \"description\": \"The key of the secret to select from.  Must be a valid secret key.\",\n        \"type\": \"string\"\n       },\n       \"name\": {\n        \"description\": \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\n        \"type\": \"string\"\n       },\n       \"optional\": {\n        \"description\": \"Specify whether the Secret or its key must be defined\",\n        \"type\": \"boolean\"\n       }\n      },\n      \"required\": [\n       \"key\"\n      ],\n      \"type\": \"object\",\n      \"x-kubernetes-map-type\": \"atomic\"\n     },\n     \"sslCert\": {\n      \"description\": \"The reference to an SSL certificate to be used to connect to this instance\",\n      \"properties\": {\n       \"key\": {\n        \"description\": \"The key of the secret to select from.  Must be a valid secret key.\",\n        \"type\": \"string\"\n       },\n       \"name\": {\n        \"description\": \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\n        \"type\": \"string\"\n       },\n       \"optional\": {\n        \"description\": \"Specify whether the Secret or its key must be defined\",\n        \"type\": \"boolean\"\n       }\n      },\n      \"required\": [\n       \"key\"\n      ],\n      \"type\": \"object\",\n      \"x-kubernetes-map-type\": \"atomic\"\n     },\n     \"sslKey\": {\n      \"description\": \"The reference to an SSL private key to be used to connect to this instance\",\n      \"properties\": {\n       \"key\": {\n        \"description\": \"The key of the secret to select from.  Must be a valid secret key.\",\n        \"type\": \"string\"\n       },\n       \"name\": {\n        \"description\": \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\n        \"type\": \"string\"\n       },\n       \"optional\": {\n        \"description\": \"Specify whether the Secret or its key must be defined\",\n        \"type\": \"boolean\"\n       }\n      },\n      \"required\": [\n       \"key\"\n      ],\n      \"type\": \"object\",\n      \"x-kubernetes-map-type\": \"atomic\"\n     },\n     \"sslRootCert\": {\n      \"description\": \"The reference to an SSL CA public key to be used to connect to this instance\",\n      \"properties\": {\n       \"key\": {\n        \"description\": \"The key of the secret to select from.  Must be a valid secret key.\",\n        \"type\": \"string\"\n       },\n       \"name\": {\n        \"description\": \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\n        \"type\": \"string\"\n       },\n       \"optional\": {\n        \"description\": \"Specify whether the Secret or its key must be defined\",\n        \"type\": \"boolean\"\n       }\n      },\n      \"required\": [\n       \"key\"\n      ],\n      \"type\": \"object\",\n      \"x-kubernetes-map-type\": \"atomic\"\n     }\n    },\n    \"required\": [\n     \"name\"\n    ],\n    \"type\": \"object\"\n   },\n   \"type\": \"array\"\n  },\n  \"imageName\": {\n   \"description\": \"Name of the container image, supporting both tags (`\\u003cimage\\u003e:\\u003ctag\\u003e`) and digests for deterministic and repeatable deployments (`\\u003cimage\\u003e:\\u003ctag\\u003e@sha256:\\u003cdigestValue\\u003e`)\",\n   \"type\": \"string\"\n  },\n  \"imagePullPolicy\": {\n   \"description\": \"Image pull policy. One of `Always`, `Never` or `IfNotPresent`. If not defined, it defaults to `IfNotPresent`. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images\",\n   \"type\": \"string\"\n  },\n  \"imagePullSecrets\": {\n   \"description\": \"The list of pull secrets to be used to pull the images\",\n   \"items\": {\n    \"description\": \"LocalObjectReference contains enough information to let you locate a local object with a known type inside the same namespace\",\n    \"properties\": {\n     \"name\": {\n      \"description\": \"Name of the referent.\",\n      \"type\": \"string\"\n     }\n    },\n    \"required\": [\n     \"name\"\n    ],\n    \"type\": \"object\"\n   },\n   \"type\": \"array\"\n  },\n  \"inheritedMetadata\": {\n   \"description\": \"Metadata that will be inherited by all objects related to the Cluster\",\n   \"properties\": {\n    \"annotations\": {\n     \"additionalProperties\": {\n      \"type\": \"string\"\n     },\n     \"type\": \"object\"\n    },\n    \"labels\": {\n     \"additionalProperties\": {\n      \"type\": \"string\"\n     },\n     \"type\": \"object\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"instances\": {\n   \"default\": 1,\n   \"description\": \"Number of instances required in the cluster\",\n   \"minimum\": 1,\n   \"type\": \"integer\"\n  },\n  \"logLevel\": {\n   \"default\": \"info\",\n   \"description\": \"The instances' log level, one of the following values: error, warning, info (default), debug, trace\",\n   \"enum\": [\n    \"error\",\n    \"warning\",\n    \"info\",\n    \"debug\",\n    \"trace\"\n   ],\n   \"type\": \"string\"\n  },\n  \"maxSyncReplicas\": {\n   \"default\": 0,\n   \"description\": \"The target value for the synchronous replication quorum, that can be decreased if the number of ready standbys is lower than this. Undefined or 0 disable synchronous replication.\",\n   \"minimum\": 0,\n   \"type\": \"integer\"\n  },\n  \"minSyncReplicas\": {\n   \"default\": 0,\n   \"description\": \"Minimum number of instances required in synchronous replication with the primary. Undefined or 0 allow writes to complete when no standby is available.\",\n   \"minimum\": 0,\n   \"type\": \"integer\"\n  },\n  \"monitoring\": {\n   \"description\": \"The configuration of the monitoring infrastructure of this cluster\",\n   \"properties\": {\n    \"customQueriesConfigMap\": {\n     \"description\": \"The list of config maps containing the custom queries\",\n     \"items\": {\n      \"description\": \"ConfigMapKeySelector contains enough information to let you locate the key of a ConfigMap\",\n      \"properties\": {\n       \"key\": {\n        \"description\": \"The key to select\",\n        \"type\": \"string\"\n       },\n       \"name\": {\n        \"description\": \"Name of the referent.\",\n        \"type\": \"string\"\n       }\n      },\n      \"required\": [\n       \"key\",\n       \"name\"\n      ],\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    },\n    \"customQueriesSecret\": {\n     \"description\": \"The list of secrets containing the custom queries\",\n     \"items\": {\n      \"description\": \"SecretKeySelector contains enough information to let you locate the key of a Secret\",\n      \"properties\": {\n       \"key\": {\n        \"description\": \"The key to select\",\n        \"type\": \"string\"\n       },\n       \"name\": {\n        \"description\": \"Name of the referent.\",\n        \"type\": \"string\"\n       }\n      },\n      \"required\": [\n       \"key\",\n       \"name\"\n      ],\n      \"type\": \"object\"\n     },\n     \"type\": \"array\"\n    },\n    \"disableDefaultQueries\": {\n     \"default\": false,\n     \"description\": \"Whether the default queries should be injected. Set it to `true` if you don't want to inject default queries into the cluster. Default: false.\",\n     \"type\": \"boolean\"\n    },\n    \"enablePodMonitor\": {\n     \"default\": false,\n     \"description\": \"Enable or disable the `PodMonitor`\",\n     \"type\": \"boolean\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"nodeMaintenanceWindow\": {\n   \"description\": \"Define a maintenance window for the Kubernetes nodes\",\n   \"properties\": {\n    \"inProgress\": {\n     \"default\": false,\n     \"description\": \"Is there a node maintenance activity in progress?\",\n     \"type\": \"boolean\"\n    },\n    \"reusePVC\": {\n     \"default\": true,\n     \"description\": \"Reuse the existing PVC (wait for the node to come up again) or not (recreate it elsewhere - when `instances` \\u003e1)\",\n     \"type\": \"boolean\"\n    }\n   },\n   \"required\": [\n    \"inProgress\"\n   ],\n   \"type\": \"object\"\n  },\n  \"postgresGID\": {\n   \"default\": 26,\n   \"description\": \"The GID of the `postgres` user inside the image, defaults to `26`\",\n   \"format\": \"int64\",\n   \"type\": \"integer\"\n  },\n  \"postgresUID\": {\n   \"default\": 26,\n   \"description\": \"The UID of the `postgres` user inside the image, defaults to `26`\",\n   \"format\": \"int64\",\n   \"type\": \"integer\"\n  },\n  \"postgresql\": {\n   \"description\": \"Configuration of the PostgreSQL server\",\n   \"properties\": {\n    \"ldap\": {\n     \"description\": \"Options to specify LDAP configuration\",\n     \"properties\": {\n      \"bindAsAuth\": {\n       \"description\": \"Bind as authentication configuration\",\n       \"properties\": {\n        \"prefix\": {\n         \"description\": \"Prefix for the bind authentication option\",\n         \"type\": \"string\"\n        },\n        \"suffix\": {\n         \"description\": \"Suffix for the bind authentication option\",\n         \"type\": \"string\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"bindSearchAuth\": {\n       \"description\": \"Bind+Search authentication configuration\",\n       \"properties\": {\n        \"baseDN\": {\n         \"description\": \"Root DN to begin the user search\",\n         \"type\": \"string\"\n        },\n        \"bindDN\": {\n         \"description\": \"DN of the user to bind to the directory\",\n         \"type\": \"string\"\n        },\n        \"bindPassword\": {\n         \"description\": \"Secret with the password for the user to bind to the directory\",\n         \"properties\": {\n          \"key\": {\n           \"description\": \"The key of the secret to select from.  Must be a valid secret key.\",\n           \"type\": \"string\"\n          },\n          \"name\": {\n           \"description\": \"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\n           \"type\": \"string\"\n          },\n          \"optional\": {\n           \"description\": \"Specify whether the Secret or its key must be defined\",\n           \"type\": \"boolean\"\n          }\n         },\n         \"required\": [\n          \"key\"\n         ],\n         \"type\": \"object\",\n         \"x-kubernetes-map-type\": \"atomic\"\n        },\n        \"searchAttribute\": {\n         \"description\": \"Attribute to match against the username\",\n         \"type\": \"string\"\n        },\n        \"searchFilter\": {\n         \"description\": \"Search filter to use when doing the search+bind authentication\",\n         \"type\": \"string\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"port\": {\n       \"description\": \"LDAP server port\",\n       \"type\": \"integer\"\n      },\n      \"scheme\": {\n       \"description\": \"LDAP schema to be used, possible options are `ldap` and `ldaps`\",\n       \"enum\": [\n        \"ldap\",\n        \"ldaps\"\n       ],\n       \"type\": \"string\"\n      },\n      \"server\": {\n       \"description\": \"LDAP hostname or IP address\",\n       \"type\": \"string\"\n      },\n      \"tls\": {\n       \"description\": \"Set to 'true' to enable LDAP over TLS. 'false' is default\",\n       \"type\": \"boolean\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"parameters\": {\n     \"additionalProperties\": {\n      \"type\": \"string\"\n     },\n     \"description\": \"PostgreSQL configuration options (postgresql.conf)\",\n     \"type\": \"object\"\n    },\n    \"pg_hba\": {\n     \"description\": \"PostgreSQL Host Based Authentication rules (lines to be appended to the pg_hba.conf file)\",\n     \"items\": {\n      \"type\": \"string\"\n     },\n     \"type\": \"array\"\n    },\n    \"promotionTimeout\": {\n     \"description\": \"Specifies the maximum number of seconds to wait when promoting an instance to primary. Default value is 40000000, greater than one year in seconds, big enough to simulate an infinite timeout\",\n     \"format\": \"int32\",\n     \"type\": \"integer\"\n    },\n    \"shared_preload_libraries\": {\n     \"description\": \"Lists of shared preload libraries to add to the default ones\",\n     \"items\": {\n      \"type\": \"string\"\n     },\n     \"type\": \"array\"\n    },\n    \"syncReplicaElectionConstraint\": {\n     \"description\": \"Requirements to be met by sync replicas. This will affect how the \\\"synchronous_standby_names\\\" parameter will be set up.\",\n     \"properties\": {\n      \"enabled\": {\n       \"description\": \"This flag enables the constraints for sync replicas\",\n       \"type\": \"boolean\"\n      },\n      \"nodeLabelsAntiAffinity\": {\n       \"description\": \"A list of node labels values to extract and compare to evaluate if the pods reside in the same topology or not\",\n       \"items\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"array\"\n      }\n     },\n     \"required\": [\n      \"enabled\"\n     ],\n     \"type\": \"object\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"primaryUpdateMethod\": {\n   \"default\": \"switchover\",\n   \"description\": \"Method to follow to upgrade the primary server during a rolling update procedure, after all replicas have been successfully updated: it can be with a switchover (`switchover` - default) or in-place (`restart`)\",\n   \"enum\": [\n    \"switchover\",\n    \"restart\"\n   ],\n   \"type\": \"string\"\n  },\n  \"primaryUpdateStrategy\": {\n   \"default\": \"unsupervised\",\n   \"description\": \"Strategy to follow to upgrade the primary server during a rolling update procedure, after all replicas have been successfully updated: it can be automated (`unsupervised` - default) or manual (`supervised`)\",\n   \"enum\": [\n    \"unsupervised\",\n    \"supervised\"\n   ],\n   \"type\": \"string\"\n  },\n  \"replica\": {\n   \"description\": \"Replica cluster configuration\",\n   \"properties\": {\n    \"enabled\": {\n     \"description\": \"If replica mode is enabled, this cluster will be a replica of an existing cluster. Replica cluster can be created from a recovery object store or via streaming through pg_basebackup. Refer to the Replication page of the documentation for more information.\",\n     \"type\": \"boolean\"\n    },\n    \"source\": {\n     \"description\": \"The name of the external cluster which is the replication origin\",\n     \"minLength\": 1,\n     \"type\": \"string\"\n    }\n   },\n   \"required\": [\n    \"source\"\n   ],\n   \"type\": \"object\"\n  },\n  \"replicationSlots\": {\n   \"description\": \"Replication slots management configuration\",\n   \"properties\": {\n    \"highAvailability\": {\n     \"description\": \"Replication slots for high availability configuration\",\n     \"properties\": {\n      \"enabled\": {\n       \"description\": \"If enabled, the operator will automatically manage replication slots on the primary instance and use them in streaming replication connections with all the standby instances that are part of the HA cluster. If disabled (default), the operator will not take advantage of replication slots in streaming connections with the replicas. This feature also controls replication slots in replica cluster, from the designated primary to its cascading replicas. This can only be set at creation time.\",\n       \"type\": \"boolean\"\n      },\n      \"slotPrefix\": {\n       \"default\": \"_cnpg_\",\n       \"description\": \"Prefix for replication slots managed by the operator for HA. It may only contain lower case letters, numbers, and the underscore character. This can only be set at creation time. By default set to `_cnpg_`.\",\n       \"pattern\": \"^[0-9a-z_]*$\",\n       \"type\": \"string\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"updateInterval\": {\n     \"default\": 30,\n     \"description\": \"Standby will update the status of the local replication slots every `updateInterval` seconds (default 30).\",\n     \"minimum\": 1,\n     \"type\": \"integer\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"resources\": {\n   \"description\": \"Resources requirements of every generated Pod. Please refer to https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/ for more information.\",\n   \"properties\": {\n    \"limits\": {\n     \"additionalProperties\": {\n      \"anyOf\": [\n       {\n        \"type\": \"integer\"\n       },\n       {\n        \"type\": \"string\"\n       }\n      ],\n      \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n      \"x-kubernetes-int-or-string\": true\n     },\n     \"description\": \"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n     \"type\": \"object\"\n    },\n    \"requests\": {\n     \"additionalProperties\": {\n      \"anyOf\": [\n       {\n        \"type\": \"integer\"\n       },\n       {\n        \"type\": \"string\"\n       }\n      ],\n      \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n      \"x-kubernetes-int-or-string\": true\n     },\n     \"description\": \"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n     \"type\": \"object\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"startDelay\": {\n   \"default\": 30,\n   \"description\": \"The time in seconds that is allowed for a PostgreSQL instance to successfully start up (default 30)\",\n   \"format\": \"int32\",\n   \"type\": \"integer\"\n  },\n  \"stopDelay\": {\n   \"default\": 30,\n   \"description\": \"The time in seconds that is allowed for a PostgreSQL instance to gracefully shutdown (default 30)\",\n   \"format\": \"int32\",\n   \"type\": \"integer\"\n  },\n  \"storage\": {\n   \"description\": \"Configuration of the storage of the instances\",\n   \"properties\": {\n    \"pvcTemplate\": {\n     \"description\": \"Template to be used to generate the Persistent Volume Claim\",\n     \"properties\": {\n      \"accessModes\": {\n       \"description\": \"accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1\",\n       \"items\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"array\"\n      },\n      \"dataSource\": {\n       \"description\": \"dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.\",\n       \"properties\": {\n        \"apiGroup\": {\n         \"description\": \"APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.\",\n         \"type\": \"string\"\n        },\n        \"kind\": {\n         \"description\": \"Kind is the type of resource being referenced\",\n         \"type\": \"string\"\n        },\n        \"name\": {\n         \"description\": \"Name is the name of resource being referenced\",\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"kind\",\n        \"name\"\n       ],\n       \"type\": \"object\",\n       \"x-kubernetes-map-type\": \"atomic\"\n      },\n      \"dataSourceRef\": {\n       \"description\": \"dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\",\n       \"properties\": {\n        \"apiGroup\": {\n         \"description\": \"APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.\",\n         \"type\": \"string\"\n        },\n        \"kind\": {\n         \"description\": \"Kind is the type of resource being referenced\",\n         \"type\": \"string\"\n        },\n        \"name\": {\n         \"description\": \"Name is the name of resource being referenced\",\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"kind\",\n        \"name\"\n       ],\n       \"type\": \"object\",\n       \"x-kubernetes-map-type\": \"atomic\"\n      },\n      \"resources\": {\n       \"description\": \"resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources\",\n       \"properties\": {\n        \"limits\": {\n         \"additionalProperties\": {\n          \"anyOf\": [\n           {\n            \"type\": \"integer\"\n           },\n           {\n            \"type\": \"string\"\n           }\n          ],\n          \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n          \"x-kubernetes-int-or-string\": true\n         },\n         \"description\": \"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"type\": \"object\"\n        },\n        \"requests\": {\n         \"additionalProperties\": {\n          \"anyOf\": [\n           {\n            \"type\": \"integer\"\n           },\n           {\n            \"type\": \"string\"\n           }\n          ],\n          \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n          \"x-kubernetes-int-or-string\": true\n         },\n         \"description\": \"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"selector\": {\n       \"description\": \"selector is a label query over volumes to consider for binding.\",\n       \"properties\": {\n        \"matchExpressions\": {\n         \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n         \"items\": {\n          \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"key is the label key that the selector applies to.\",\n            \"type\": \"string\"\n           },\n           \"operator\": {\n            \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n            \"type\": \"string\"\n           },\n           \"values\": {\n            \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"operator\"\n          ],\n          \"type\": \"object\"\n         },\n         \"type\": \"array\"\n        },\n        \"matchLabels\": {\n         \"additionalProperties\": {\n          \"type\": \"string\"\n         },\n         \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\",\n       \"x-kubernetes-map-type\": \"atomic\"\n      },\n      \"storageClassName\": {\n       \"description\": \"storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1\",\n       \"type\": \"string\"\n      },\n      \"volumeMode\": {\n       \"description\": \"volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.\",\n       \"type\": \"string\"\n      },\n      \"volumeName\": {\n       \"description\": \"volumeName is the binding reference to the PersistentVolume backing this claim.\",\n       \"type\": \"string\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"resizeInUseVolumes\": {\n     \"default\": true,\n     \"description\": \"Resize existent PVCs, defaults to true\",\n     \"type\": \"boolean\"\n    },\n    \"size\": {\n     \"description\": \"Size of the storage. Required if not already specified in the PVC template. Changes to this field are automatically reapplied to the created PVCs. Size cannot be decreased.\",\n     \"type\": \"string\"\n    },\n    \"storageClass\": {\n     \"description\": \"StorageClass to use for database data (`PGDATA`). Applied after evaluating the PVC template, if available. If not specified, generated PVCs will be satisfied by the default storage class\",\n     \"type\": \"string\"\n    }\n   },\n   \"type\": \"object\"\n  },\n  \"superuserSecret\": {\n   \"description\": \"The secret containing the superuser password. If not defined a new secret will be created with a randomly generated password\",\n   \"properties\": {\n    \"name\": {\n     \"description\": \"Name of the referent.\",\n     \"type\": \"string\"\n    }\n   },\n   \"required\": [\n    \"name\"\n   ],\n   \"type\": \"object\"\n  },\n  \"switchoverDelay\": {\n   \"default\": 40000000,\n   \"description\": \"The time in seconds that is allowed for a primary PostgreSQL instance to gracefully shutdown during a switchover. Default value is 40000000, greater than one year in seconds, big enough to simulate an infinite delay\",\n   \"format\": \"int32\",\n   \"type\": \"integer\"\n  },\n  \"walStorage\": {\n   \"description\": \"Configuration of the storage for PostgreSQL WAL (Write-Ahead Log)\",\n   \"properties\": {\n    \"pvcTemplate\": {\n     \"description\": \"Template to be used to generate the Persistent Volume Claim\",\n     \"properties\": {\n      \"accessModes\": {\n       \"description\": \"accessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1\",\n       \"items\": {\n        \"type\": \"string\"\n       },\n       \"type\": \"array\"\n      },\n      \"dataSource\": {\n       \"description\": \"dataSource field can be used to specify either: * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot) * An existing PVC (PersistentVolumeClaim) If the provisioner or an external controller can support the specified data source, it will create a new volume based on the contents of the specified data source. If the AnyVolumeDataSource feature gate is enabled, this field will always have the same contents as the DataSourceRef field.\",\n       \"properties\": {\n        \"apiGroup\": {\n         \"description\": \"APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.\",\n         \"type\": \"string\"\n        },\n        \"kind\": {\n         \"description\": \"Kind is the type of resource being referenced\",\n         \"type\": \"string\"\n        },\n        \"name\": {\n         \"description\": \"Name is the name of resource being referenced\",\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"kind\",\n        \"name\"\n       ],\n       \"type\": \"object\",\n       \"x-kubernetes-map-type\": \"atomic\"\n      },\n      \"dataSourceRef\": {\n       \"description\": \"dataSourceRef specifies the object from which to populate the volume with data, if a non-empty volume is desired. This may be any local object from a non-empty API group (non core object) or a PersistentVolumeClaim object. When this field is specified, volume binding will only succeed if the type of the specified object matches some installed volume populator or dynamic provisioner. This field will replace the functionality of the DataSource field and as such if both fields are non-empty, they must have the same value. For backwards compatibility, both fields (DataSource and DataSourceRef) will be set to the same value automatically if one of them is empty and the other is non-empty. There are two important differences between DataSource and DataSourceRef: * While DataSource only allows two specific types of objects, DataSourceRef allows any non-core object, as well as PersistentVolumeClaim objects. * While DataSource ignores disallowed values (dropping them), DataSourceRef preserves all values, and generates an error if a disallowed value is specified. (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.\",\n       \"properties\": {\n        \"apiGroup\": {\n         \"description\": \"APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.\",\n         \"type\": \"string\"\n        },\n        \"kind\": {\n         \"description\": \"Kind is the type of resource being referenced\",\n         \"type\": \"string\"\n        },\n        \"name\": {\n         \"description\": \"Name is the name of resource being referenced\",\n         \"type\": \"string\"\n        }\n       },\n       \"required\": [\n        \"kind\",\n        \"name\"\n       ],\n       \"type\": \"object\",\n       \"x-kubernetes-map-type\": \"atomic\"\n      },\n      \"resources\": {\n       \"description\": \"resources represents the minimum resources the volume should have. If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements that are lower than previous value but must still be higher than capacity recorded in the status field of the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources\",\n       \"properties\": {\n        \"limits\": {\n         \"additionalProperties\": {\n          \"anyOf\": [\n           {\n            \"type\": \"integer\"\n           },\n           {\n            \"type\": \"string\"\n           }\n          ],\n          \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n          \"x-kubernetes-int-or-string\": true\n         },\n         \"description\": \"Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"type\": \"object\"\n        },\n        \"requests\": {\n         \"additionalProperties\": {\n          \"anyOf\": [\n           {\n            \"type\": \"integer\"\n           },\n           {\n            \"type\": \"string\"\n           }\n          ],\n          \"pattern\": \"^(\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\\\\+|-)?(([0-9]+(\\\\.[0-9]*)?)|(\\\\.[0-9]+))))?$\",\n          \"x-kubernetes-int-or-string\": true\n         },\n         \"description\": \"Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/\",\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\"\n      },\n      \"selector\": {\n       \"description\": \"selector is a label query over volumes to consider for binding.\",\n       \"properties\": {\n        \"matchExpressions\": {\n         \"description\": \"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\n         \"items\": {\n          \"description\": \"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\n          \"properties\": {\n           \"key\": {\n            \"description\": \"key is the label key that the selector applies to.\",\n            \"type\": \"string\"\n           },\n           \"operator\": {\n            \"description\": \"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\n            \"type\": \"string\"\n           },\n           \"values\": {\n            \"description\": \"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\n            \"items\": {\n             \"type\": \"string\"\n            },\n            \"type\": \"array\"\n           }\n          },\n          \"required\": [\n           \"key\",\n           \"operator\"\n          ],\n          \"type\": \"object\"\n         },\n         \"type\": \"array\"\n        },\n        \"matchLabels\": {\n         \"additionalProperties\": {\n          \"type\": \"string\"\n         },\n         \"description\": \"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\n         \"type\": \"object\"\n        }\n       },\n       \"type\": \"object\",\n       \"x-kubernetes-map-type\": \"atomic\"\n      },\n      \"storageClassName\": {\n       \"description\": \"storageClassName is the name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1\",\n       \"type\": \"string\"\n      },\n      \"volumeMode\": {\n       \"description\": \"volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec.\",\n       \"type\": \"string\"\n      },\n      \"volumeName\": {\n       \"description\": \"volumeName is the binding reference to the PersistentVolume backing this claim.\",\n       \"type\": \"string\"\n      }\n     },\n     \"type\": \"object\"\n    },\n    \"resizeInUseVolumes\": {\n     \"default\": true,\n     \"description\": \"Resize existent PVCs, defaults to true\",\n     \"type\": \"boolean\"\n    },\n    \"size\": {\n     \"description\": \"Size of the storage. Required if not already specified in the PVC template. Changes to this field are automatically reapplied to the created PVCs. Size cannot be decreased.\",\n     \"type\": \"string\"\n    },\n    \"storageClass\": {\n     \"description\": \"StorageClass to use for database data (`PGDATA`). Applied after evaluating the PVC template, if available. If not specified, generated PVCs will be satisfied by the default storage class\",\n     \"type\": \"string\"\n    }\n   },\n   \"type\": \"object\"\n  }\n },\n \"required\": [\n  \"instances\"\n ],\n \"title\": \"Cluster\",\n \"type\": \"object\"\n}"}